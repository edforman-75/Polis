<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campaign Content Editor - Synchronized Multi-Surface Editor</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8fafc;
            color: #1a202c;
            overflow-x: hidden;
        }

        .editor-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: white;
            padding: 1rem 2rem;
            border-bottom: 1px solid #e2e8f0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            z-index: 100;
        }

        .header h1 {
            font-size: 1.5rem;
            color: #2d3748;
            margin-bottom: 0.5rem;
        }

        .header p {
            color: #718096;
            font-size: 0.9rem;
        }

        .server-status {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            margin-left: 1rem;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #f56565;
        }

        .status-indicator.connected { background: #48bb78; }

        .surfaces-container {
            flex: 1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 1px;
            background: #e2e8f0;
            overflow: hidden;
        }

        .surface {
            background: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .surface-header {
            background: #f7fafc;
            border-bottom: 1px solid #e2e8f0;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .surface-title {
            font-weight: 600;
            color: #2d3748;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .surface-controls {
            display: flex;
            gap: 0.5rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #4299e1;
            color: white;
        }

        .btn-primary:hover { background: #3182ce; }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover { background: #cbd5e1; }

        .surface-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .editor-canvas {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .text-editor {
            flex: 1;
            padding: 1rem;
            border: none;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: none;
            outline: none;
            background: transparent;
        }

        .text-editor:focus {
            background: #f7fafc;
        }

        .analysis-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            padding: 1rem;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: transparent;
            white-space: pre-wrap;
            overflow: hidden;
        }

        .highlight {
            background: rgba(239, 68, 68, 0.2);
            border-bottom: 2px solid #ef4444;
            border-radius: 2px;
            position: relative;
            pointer-events: auto;
            cursor: pointer;
        }

        .highlight.grammar { background: rgba(239, 68, 68, 0.2); border-color: #ef4444; }
        .highlight.tone { background: rgba(59, 130, 246, 0.2); border-color: #3b82f6; }
        .highlight.narrative { background: rgba(16, 185, 129, 0.2); border-color: #10b981; }
        .highlight.compliance { background: rgba(245, 101, 101, 0.2); border-color: #f56565; }
        .highlight.fact-check { background: rgba(251, 191, 36, 0.2); border-color: #fbbf24; }
        .highlight.ai-optimization { background: rgba(139, 92, 246, 0.2); border-color: #8b5cf6; }

        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #1a202c;
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
        }

        .highlight:hover .tooltip { opacity: 1; }

        .recommendations-panel {
            max-height: 200px;
            overflow-y: auto;
            border-top: 1px solid #e2e8f0;
            background: #f7fafc;
        }

        .recommendation {
            padding: 0.75rem;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }

        .recommendation:last-child { border-bottom: none; }

        .recommendation-type {
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.25rem;
        }

        .recommendation-text {
            color: #2d3748;
            margin-bottom: 0.5rem;
        }

        .recommendation-action {
            font-size: 0.8rem;
            color: #4299e1;
            cursor: pointer;
        }

        .recommendation-action:hover { text-decoration: underline; }

        .sync-indicator {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: #48bb78;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .sync-indicator.active { opacity: 1; }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        .loading-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .spinner {
            width: 32px;
            height: 32px;
            border: 3px solid #e2e8f0;
            border-top: 3px solid #4299e1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 1200px) {
            .surfaces-container {
                grid-template-columns: 1fr;
                overflow-y: auto;
            }
        }
    </style>
</head>
<body>
    <div class="editor-container">
        <div class="header">
            <h1>ðŸŽ¯ Synchronized Multi-Surface Editor</h1>
            <p>Real-time collaborative analysis across all editorial surfaces</p>
            <span class="server-status">
                <span class="status-indicator" id="server-status"></span>
                <span id="server-text">Checking connection...</span>
            </span>
        </div>

        <div class="surfaces-container" id="surfaces-container">
            <!-- Surfaces will be dynamically generated -->
        </div>
    </div>

    <div class="sync-indicator" id="sync-indicator">
        Syncing changes across surfaces...
    </div>

    <script>
        // Global state management
        const EditorState = {
            currentText: '',
            analyses: {},
            surfaces: [],
            syncTimeout: null,
            isAnalyzing: false
        };

        // Surface configurations
        const SURFACE_CONFIGS = {
            tone: {
                title: 'ðŸŽ­ Tone Analysis',
                endpoint: '/api/analyze/tone',
                highlightClass: 'tone',
                description: 'Communication style and emotional resonance'
            },
            grammar: {
                title: 'ðŸ“ Grammar Check',
                endpoint: '/api/analyze/grammar',
                highlightClass: 'grammar',
                description: 'Grammar, readability, and writing style'
            },
            narrative: {
                title: 'ðŸ“– Narrative Flow',
                endpoint: '/api/analyze/narrative',
                highlightClass: 'narrative',
                description: 'Story structure and message coherence'
            },
            compliance: {
                title: 'âš–ï¸ Compliance Check',
                endpoint: '/api/analyze/compliance',
                highlightClass: 'compliance',
                description: 'Legal and regulatory compliance'
            },
            'fact-checking': {
                title: 'ðŸ” Fact Check',
                endpoint: '/api/analyze/fact-checking',
                highlightClass: 'fact-check',
                description: 'Factual accuracy and verification'
            },
            'ai-optimization': {
                title: 'ðŸ¤– AI Optimization',
                endpoint: '/api/analyze/ai-optimization',
                highlightClass: 'ai-optimization',
                description: 'Content optimization recommendations'
            }
        };

        // Initialize the editor
        async function initializeEditor() {
            checkServerConnection();
            createSurfaces();
            loadSampleContent();

            // Set up periodic server health checks
            setInterval(checkServerConnection, 30000);
        }

        // Check server connection
        async function checkServerConnection() {
            try {
                const response = await fetch('/api/health');
                const data = await response.json();

                document.getElementById('server-status').classList.add('connected');
                document.getElementById('server-text').textContent = 'Server connected';
            } catch (error) {
                document.getElementById('server-status').classList.remove('connected');
                document.getElementById('server-text').textContent = 'Server disconnected';
            }
        }

        // Create surface canvases
        function createSurfaces() {
            const container = document.getElementById('surfaces-container');

            Object.entries(SURFACE_CONFIGS).forEach(([type, config]) => {
                const surface = createSurface(type, config);
                container.appendChild(surface);
                EditorState.surfaces.push({ type, element: surface });
            });
        }

        // Create individual surface
        function createSurface(type, config) {
            const surface = document.createElement('div');
            surface.className = 'surface';
            surface.id = `surface-${type}`;

            surface.innerHTML = `
                <div class="surface-header">
                    <div class="surface-title">
                        ${config.title}
                        <span style="font-size: 0.7rem; color: #718096; font-weight: normal;">${config.description}</span>
                    </div>
                    <div class="surface-controls">
                        <button class="btn btn-secondary" onclick="analyzeSurface('${type}')">Analyze</button>
                        <button class="btn btn-primary" onclick="applySuggestion('${type}')">Apply Fix</button>
                    </div>
                </div>
                <div class="surface-content">
                    <div class="editor-canvas">
                        <textarea
                            class="text-editor"
                            id="editor-${type}"
                            placeholder="Content will sync across all surfaces..."
                            oninput="handleTextChange('${type}')"
                        ></textarea>
                        <div class="analysis-overlay" id="overlay-${type}"></div>
                        <div class="loading-overlay" id="loading-${type}">
                            <div class="spinner"></div>
                        </div>
                    </div>
                    <div class="recommendations-panel" id="recommendations-${type}">
                        <div class="recommendation">
                            <div class="recommendation-type">Ready for Analysis</div>
                            <div class="recommendation-text">Make changes to see contextual recommendations and issue highlighting.</div>
                        </div>
                    </div>
                </div>
            `;

            return surface;
        }

        // Handle text changes with synchronization
        function handleTextChange(sourceSurface) {
            const textarea = document.getElementById(`editor-${sourceSurface}`);
            const newText = textarea.value;

            // Update global state
            EditorState.currentText = newText;

            // Sync to all other surfaces
            syncTextAcrossSurfaces(sourceSurface, newText);

            // Debounced analysis trigger
            clearTimeout(EditorState.syncTimeout);
            EditorState.syncTimeout = setTimeout(() => {
                triggerAnalysisForAllSurfaces();
            }, 1000);

            // Show sync indicator
            showSyncIndicator();
        }

        // Sync text across all surfaces
        function syncTextAcrossSurfaces(sourceSurface, text) {
            EditorState.surfaces.forEach(({ type }) => {
                if (type !== sourceSurface) {
                    const editor = document.getElementById(`editor-${type}`);
                    if (editor && editor.value !== text) {
                        editor.value = text;
                    }
                }
            });
        }

        // Show sync indicator
        function showSyncIndicator() {
            const indicator = document.getElementById('sync-indicator');
            indicator.classList.add('active');
            setTimeout(() => {
                indicator.classList.remove('active');
            }, 1500);
        }

        // Trigger analysis for all surfaces
        async function triggerAnalysisForAllSurfaces() {
            if (EditorState.isAnalyzing || !EditorState.currentText.trim()) return;

            EditorState.isAnalyzing = true;

            // Analyze each surface concurrently
            const analysisPromises = EditorState.surfaces.map(({ type }) =>
                analyzeSurface(type, false)
            );

            try {
                await Promise.all(analysisPromises);
            } finally {
                EditorState.isAnalyzing = false;
            }
        }

        // Analyze specific surface
        async function analyzeSurface(type, showLoading = true) {
            const config = SURFACE_CONFIGS[type];
            const text = EditorState.currentText;

            if (!text.trim()) return;

            if (showLoading) {
                document.getElementById(`loading-${type}`).classList.add('active');
            }

            try {
                const response = await fetch(config.endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text })
                });

                const result = await response.json();

                if (result.success) {
                    EditorState.analyses[type] = result.analysis;
                    updateSurfaceDisplay(type, result.analysis);
                } else {
                    showError(type, result.error);
                }
            } catch (error) {
                showError(type, error.message);
            } finally {
                if (showLoading) {
                    document.getElementById(`loading-${type}`).classList.remove('active');
                }
            }
        }

        // Update surface display with analysis results
        function updateSurfaceDisplay(type, analysis) {
            updateHighlights(type, analysis);
            updateRecommendations(type, analysis);
        }

        // Update text highlights
        function updateHighlights(type, analysis) {
            const overlay = document.getElementById(`overlay-${type}`);
            const config = SURFACE_CONFIGS[type];
            const text = EditorState.currentText;

            let highlightedText = text;
            const issues = extractIssues(type, analysis);

            // Sort issues by position (descending) to avoid offset problems
            issues.sort((a, b) => b.start - a.start);

            issues.forEach(issue => {
                const beforeText = highlightedText.substring(0, issue.start);
                const issueText = highlightedText.substring(issue.start, issue.end);
                const afterText = highlightedText.substring(issue.end);

                const highlightHtml = `<span class="highlight ${config.highlightClass}" data-issue="${encodeURIComponent(JSON.stringify(issue))}">
                    ${issueText}
                    <span class="tooltip">${issue.message}</span>
                </span>`;

                highlightedText = beforeText + highlightHtml + afterText;
            });

            overlay.innerHTML = highlightedText;
        }

        // Extract issues from analysis results
        function extractIssues(type, analysis) {
            const issues = [];
            const text = EditorState.currentText;

            switch (type) {
                case 'grammar':
                    if (analysis.grammar_issues) {
                        analysis.grammar_issues.forEach((issue, index) => {
                            // Simple text matching for demonstration
                            const problemText = issue.text || issue.description || 'issue';
                            const position = text.indexOf(problemText);
                            if (position !== -1) {
                                issues.push({
                                    start: position,
                                    end: position + problemText.length,
                                    message: issue.description || issue.message || 'Grammar issue',
                                    type: 'grammar',
                                    suggestion: issue.suggestion
                                });
                            }
                        });
                    }
                    break;

                case 'tone':
                    // Add tone-specific issue extraction
                    if (analysis.recommendations) {
                        analysis.recommendations.forEach(rec => {
                            // This is a simplified approach - in practice you'd want more sophisticated text matching
                            if (rec.includes('formal') || rec.includes('tone')) {
                                const position = Math.floor(text.length * 0.3); // Example positioning
                                issues.push({
                                    start: position,
                                    end: position + 20,
                                    message: rec,
                                    type: 'tone'
                                });
                            }
                        });
                    }
                    break;

                // Add more specific issue extraction for other analysis types
                default:
                    // Generic issue extraction
                    if (analysis.recommendations) {
                        analysis.recommendations.slice(0, 2).forEach((rec, index) => {
                            const position = Math.floor(text.length * (0.2 + index * 0.3));
                            issues.push({
                                start: position,
                                end: position + 15,
                                message: rec,
                                type: type
                            });
                        });
                    }
            }

            return issues;
        }

        // Update recommendations panel
        function updateRecommendations(type, analysis) {
            const panel = document.getElementById(`recommendations-${type}`);
            const recommendations = analysis.recommendations || [];

            if (recommendations.length === 0) {
                panel.innerHTML = `
                    <div class="recommendation">
                        <div class="recommendation-type">Analysis Complete</div>
                        <div class="recommendation-text">No issues found in this analysis.</div>
                    </div>
                `;
                return;
            }

            const html = recommendations.slice(0, 5).map((rec, index) => `
                <div class="recommendation">
                    <div class="recommendation-type">${type.charAt(0).toUpperCase() + type.slice(1)} Suggestion ${index + 1}</div>
                    <div class="recommendation-text">${rec}</div>
                    <div class="recommendation-action" onclick="applyRecommendation('${type}', ${index})">
                        Apply this suggestion
                    </div>
                </div>
            `).join('');

            panel.innerHTML = html;
        }

        // Show error message
        function showError(type, message) {
            const panel = document.getElementById(`recommendations-${type}`);
            panel.innerHTML = `
                <div class="recommendation">
                    <div class="recommendation-type">Analysis Error</div>
                    <div class="recommendation-text">Error: ${message}</div>
                    <div class="recommendation-action" onclick="analyzeSurface('${type}')">
                        Retry analysis
                    </div>
                </div>
            `;
        }

        // Apply recommendation
        function applyRecommendation(type, index) {
            // This is a placeholder - in practice you'd implement actual text transformation
            alert(`Applied ${type} recommendation ${index + 1}. This would modify the text based on the specific suggestion.`);
        }

        // Apply suggestion (placeholder)
        function applySuggestion(type) {
            const analysis = EditorState.analyses[type];
            if (analysis && analysis.recommendations && analysis.recommendations.length > 0) {
                applyRecommendation(type, 0);
            } else {
                alert(`No suggestions available for ${type}. Run analysis first.`);
            }
        }

        // Load sample content
        function loadSampleContent() {
            const sampleText = `PRESS RELEASE
November 13, 2023
SPANBERGER ANNOUNCES RUN FOR GOVERNOR OF VIRGINIA

HENRICO, Va. â€” U.S. Representative Abigail Spanberger today announced that she is running to become the 75th Governor of Virginia and will not seek reelection to the U.S. House in 2024.

"The greatest honor of my life has been to represent Virginians in the U.S. House. Today, I am proud to announce that I will be working hard to gain the support and trust of all Virginians to continue this service as the next Governor of Virginia," said Spanberger. "Virginia is where I grew up, where I am raising my own family, and where I intend to build a stronger future for the next generation of Virginians. As a former CIA case officer, former federal law enforcement officer, and current Member of Congress, I have always believed in the value of public service. I look forward to serving the Seventh District through the end of this term and then pursuing the important work of bringing Virginia together to keep our Commonwealth strong."

Today, Spanberger released "What Matters Most," an announcement video highlighting her record of public service, her commitment to the future of Virginia, and her reputation for getting things done.`;

            EditorState.currentText = sampleText;

            // Load into all surfaces
            EditorState.surfaces.forEach(({ type }) => {
                document.getElementById(`editor-${type}`).value = sampleText;
            });

            // Trigger initial analysis
            setTimeout(() => {
                triggerAnalysisForAllSurfaces();
            }, 1000);
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', initializeEditor);
    </script>
</body>
</html>