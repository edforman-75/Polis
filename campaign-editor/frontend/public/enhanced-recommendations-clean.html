<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Recommendations Editor - Generalized for Any Campaign 9:45pm</title>
    <!-- Cache buster: v10-double-click-sentence-fix -->
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4F46E5 0%, #7C3AED 100%);
            color: white;
            padding: 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 700;
        }

        .header-subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-top: 0.5rem;
        }

        .header-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .analyze-button, .undo-button {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 0.95rem;
        }

        .analyze-button:hover, .undo-button:hover:not(:disabled) {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.5);
            transform: translateY(-2px);
        }

        .undo-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10B981;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            min-height: 600px;
        }

        .editor-section {
            padding: 2rem;
            border-right: 1px solid #E5E7EB;
        }

        .editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .editor-header h3 {
            color: #1F2937;
            font-size: 1.25rem;
        }

        .text-editor {
            width: 100%;
            height: 1250px;
            padding: 1.5rem;
            border: 2px solid #E5E7EB;
            border-radius: 8px;
            font-size: 1rem;
            line-height: 1.6;
            resize: vertical;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            position: relative;
            background: white;
            z-index: 2;
        }

        /* Custom selection highlighting */
        .text-editor::selection {
            background: #FBBF24;
            color: #92400E;
        }

        .text-editor::-moz-selection {
            background: #FBBF24;
            color: #92400E;
        }

        .text-editor.highlighting::selection {
            background: #F59E0B !important;
            color: #451a03 !important;
        }

        .text-editor.highlighting::-moz-selection {
            background: #F59E0B !important;
            color: #451a03 !important;
        }

        .text-editor-container {
            position: relative;
            width: 100%;
        }

        .highlight-overlay {
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            padding: 1.5rem;
            pointer-events: none;
            font-size: 1rem;
            line-height: 1.6;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow: hidden;
            color: transparent;
            z-index: 1;
            border-radius: 6px;
            background: white;
        }

        .highlighted-text-overlay {
            background-color: #FBBF24 !important;
            border: 3px solid #F59E0B !important;
            border-radius: 4px !important;
            padding: 2px 4px !important;
            color: #92400E !important;
            font-weight: bold !important;
            animation: highlightPulse 3s ease-in-out infinite !important;
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.6) !important;
        }

        @keyframes highlightPulse {
            0%, 100% {
                background-color: #FBBF24 !important;
                transform: scale(1) !important;
            }
            50% {
                background-color: #F59E0B !important;
                transform: scale(1.05) !important;
            }
        }

        .text-editor:focus {
            outline: none;
            border-color: #4F46E5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        .recommendations-panel {
            padding: 2rem;
            background: #F9FAFB;
        }

        .recommendations-header {
            margin-bottom: 1.5rem;
        }

        .recommendations-header h3 {
            color: #1F2937;
            font-size: 1.25rem;
            margin-bottom: 0.5rem;
        }

        .progress-indicator {
            margin-bottom: 1rem;
            padding: 1rem;
            background: white;
            border-radius: 8px;
            border: 1px solid #E5E7EB;
        }

        .progress-bar-container {
            background: #F3F4F6;
            border-radius: 10px;
            height: 8px;
            margin-bottom: 0.5rem;
            overflow: hidden;
        }

        .progress-bar {
            background: linear-gradient(90deg, #4F46E5 0%, #059669 100%);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            font-size: 0.9rem;
            color: #374151;
            font-weight: 500;
            text-align: center;
        }

        .recommendations-summary {
            color: #6B7280;
            font-size: 0.95rem;
            padding: 1rem;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #4F46E5;
        }

        .recommendations-list {
            background: white;
            border-radius: 8px;
            min-height: 400px;
            padding: 1.5rem;
        }

        .loading-indicator {
            text-align: center;
            color: #6B7280;
            font-style: italic;
            padding: 2rem;
        }

        .recommendation {
            border: 1px solid #E5E7EB;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            background: white;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .recommendation.collapsed {
            padding: 0.75rem 1.5rem;
            margin-bottom: 0.5rem;
            max-height: 80px;
        }

        .recommendation.collapsed .recommendation-details {
            display: none;
        }

        .recommendation.collapsed .recommendation-header {
            margin-bottom: 0;
        }

        .recommendation.expanded {
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.15);
            border-color: #4F46E5;
        }

        .recommendation-details {
            transition: all 0.3s ease;
        }

        .recommendation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .recommendation-type {
            font-weight: 600;
            color: #1F2937;
            font-size: 1.1rem;
        }

        .recommendation-severity {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .recommendation-severity.high {
            background: #FEE2E2;
            color: #DC2626;
        }

        .recommendation-severity.medium {
            background: #FEF3C7;
            color: #D97706;
        }

        .recommendation-severity.low {
            background: #D1FAE5;
            color: #059669;
        }

        .recommendation-issue {
            color: #374151;
            margin-bottom: 0.75rem;
            font-weight: 500;
        }

        .recommendation-explanation {
            color: #6B7280;
            margin-bottom: 1rem;
            line-height: 1.5;
        }

        .error-message {
            background: #FEF2F2;
            border: 1px solid #FECACA;
            border-radius: 8px;
            padding: 1rem;
            color: #DC2626;
        }

        .error-message h3 {
            margin-bottom: 0.5rem;
        }

        .highlighted-text {
            background-color: #FEF3C7;
            border: 2px solid #F59E0B;
            border-radius: 4px;
            padding: 2px 4px;
            margin: 0 2px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .highlighted-text:hover {
            background-color: #FDE68A;
            border-color: #D97706;
        }

        .recommendation-context {
            background: #F3F4F6;
            border-radius: 6px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9rem;
            border-left: 4px solid #6B7280;
        }

        .before-after-preview {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
            padding: 1rem;
            background: #F9FAFB;
            border-radius: 8px;
        }

        .preview-section {
            padding: 1rem;
            border-radius: 6px;
        }

        .before-text {
            background: #FEF2F2;
            border: 1px solid #FECACA;
        }

        .after-text {
            background: #F0FDF4;
            border: 1px solid #BBF7D0;
        }

        .preview-label {
            font-weight: 600;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .alternative-suggestions {
            margin: 1.5rem 0;
        }

        .alternative-suggestions h4 {
            color: #374151;
            margin-bottom: 1rem;
            font-size: 1rem;
        }

        .suggestion-item {
            background: #F8FAFC;
            border: 1px solid #E2E8F0;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .suggestion-item:hover {
            background: #EDF2F7;
            border-color: #CBD5E0;
        }

        .suggestion-item.selected {
            background: #EBF8FF;
            border-color: #3182CE;
        }

        .suggestion-label {
            font-weight: 600;
            color: #2D3748;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .suggestion-text {
            color: #4A5568;
            font-style: italic;
        }

        .recommendation-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .action-button {
            background: #4F46E5;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .action-button:hover {
            background: #4338CA;
            transform: translateY(-1px);
        }

        .action-button.secondary {
            background: #6B7280;
        }

        .action-button.secondary:hover {
            background: #4B5563;
        }

        .action-button.apply {
            background: #059669;
        }

        .action-button.apply:hover {
            background: #047857;
        }

        .completion-message {
            text-align: center;
            padding: 3rem 2rem;
            background: linear-gradient(135deg, #F0FDF4 0%, #ECFDF5 100%);
            border-radius: 12px;
            border: 2px solid #059669;
        }

        .completion-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
        }

        .completion-message h3 {
            color: #047857;
            font-size: 1.5rem;
            margin-bottom: 1rem;
        }

        .completion-message p {
            color: #065F46;
            margin-bottom: 2rem;
            font-size: 1.1rem;
        }

        .completion-stats {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .stat {
            text-align: center;
        }

        .stat strong {
            display: block;
            font-size: 2rem;
            color: #047857;
            font-weight: 700;
        }

        .stat span {
            color: #065F46;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .editor-section {
                border-right: none;
                border-bottom: 1px solid #E5E7EB;
            }

            .header {
                text-align: center;
            }

            .header-controls {
                justify-content: center;
            }

            .before-after-preview {
                grid-template-columns: 1fr;
            }

            .recommendation-actions {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div>
                <h1>üéØ Enhanced Recommendations Editor</h1>
                <div class="header-subtitle">Directive recommendations with actionable options</div>
            </div>
            <div class="header-controls">
                <button onclick="loadSampleContent()" class="analyze-button">üìÑ Load Sample</button>
                <button onclick="runToneAnalysis()" class="analyze-button">üé≠ Analyze Tone</button>
                <button onclick="undoLastChange()" class="undo-button" id="undo-button" disabled>‚Ü∂ Undo</button>
                <div class="status-indicator">
                    <div class="status-dot"></div>
                    <span>Server connected</span>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="editor-section">
                <div class="editor-header">
                    <h3>Content Editor</h3>
                    <div>
                        <span id="issue-count" style="color: #718096; font-size: 0.9rem;">0 issues found</span>
                    </div>
                </div>
                <div class="text-editor-container">
                    <textarea id="text-editor" class="text-editor" placeholder="Paste your campaign content here for analysis with enhanced recommendations..." oninput="enableUndo()"></textarea>
                    <div id="highlight-overlay" class="highlight-overlay"></div>
                </div>
            </div>

            <div class="recommendations-panel">
                <div class="recommendations-header">
                    <h3>üí° Enhanced Recommendations</h3>
                    <div class="progress-indicator" id="progress-indicator" style="display: none;">
                        <div class="progress-bar-container">
                            <div class="progress-bar" id="progress-bar"></div>
                        </div>
                        <div class="progress-text" id="progress-text">0 of 0 completed</div>
                    </div>
                    <div class="recommendations-summary" id="analysis-summary">Click "Analyze Tone" to see directive recommendations</div>
                </div>
                <div class="recommendations-list" id="recommendations-list">
                    <div class="loading-indicator">Enhanced recommendations with actionable options will appear here</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let undoStack = [];
        let currentText = '';

        // Sample content for testing - Generic Campaign Press Release
        const SAMPLE_TEXT = `PRESS RELEASES
Nov 13, 2023
CANDIDATE ANNOUNCES RUN FOR GOVERNOR
CITY, State ‚Äî U.S. Representative Jane Candidate today announced that she is running to become the next Governor and will not seek reelection to the U.S. House in 2024.

"The greatest honor of my life has been to represent the people of this district in the U.S. House. Today, I am proud to announce that I will be working hard to gain the support and trust of all voters to continue this service as the next Governor," said Candidate. "This state is where I grew up, where I am raising my own family, and where I intend to build a stronger future for the next generation. As a former law enforcement officer and current Member of Congress, I have always believed in the value of public service. I look forward to serving this district through the end of this term and then pursuing the important work of bringing our state together to keep our communities strong."

‚Äî

Today, Candidate released "Our Shared Vision," an announcement video highlighting her record of public service, her commitment to the future of the state, and her reputation for getting things done.

Click here to watch, and a full transcript is below.

‚Äî

From our beautiful landscapes to our diverse communities, this state is a lot of things. But most importantly, it's home.

I'm Jane Candidate. I grew up here in the central part of our state. And now, my spouse and I are raising our children here. Teaching them, like my parents taught me, that if you see something wrong, do everything in your power to right it.

It's why I committed to a life of service for our country and the people of this state. First in law enforcement, then working to keep our communities safe, and today in Congress. Where, despite dangerous polarization, I have found ways to bring people together and focus on what really matters.

Providing veterans with the support they need, supporting small businesses so they can grow, assisting families and communities struggling with addiction. Proving that to get things done, people must come first.

But today, we find ourselves at a crossroads. Our country and our state are facing fundamental threats to our rights, our freedoms, and to our democracy. While some politicians focus on divisive issues, what they're not doing is helping people.

I know how to bring people together and get real things done that improve lives.

That's why I'm running for Governor.

Because when we rise above the chaos and division, we can focus on what matters most: lowering prescription drug prices, growing the middle class, lowering costs, and easing inflation. No more using teachers and our kids as political pawns ‚Äî it's about focusing on recruiting and retaining teachers, so all of our kids can succeed. And protecting fundamental rights.

Even in this moment of deep division, we can seize the opportunity. I am running to serve all voters in every community across our state, because it's about time we do what's right for everyone.

And that's what matters most.

‚Äî

BACKGROUND

U.S. Rep. Jane Candidate is serving her third term in the U.S. House of Representatives. In Congress, she serves on key committees and has consistently been ranked as one of the most effective lawmakers in the country.

Before Congress, Candidate served as a law enforcement officer and community leader. She and her spouse are the proud parents of school-aged children`;

        // Load sample content
        function loadSampleContent() {
            console.log('üìÑ Loading sample content');
            const editor = document.getElementById('text-editor');

            if (!editor) {
                console.error('‚ùå text-editor element not found');
                alert('Error: Could not find text editor element');
                return;
            }

            console.log('‚úÖ text-editor element found');
            console.log('üìä Sample text length:', SAMPLE_TEXT.length);

            editor.value = SAMPLE_TEXT;
            console.log('‚úÖ Sample text loaded into editor');
            console.log('üìÑ Editor value length after loading:', editor.value.length);

            saveState();
            console.log('‚úÖ State saved');

            // Show notification to user
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #059669;
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 10000;
                font-family: system-ui;
            `;
            notification.textContent = 'üìÑ Sample content loaded successfully!';
            document.body.appendChild(notification);

            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }

        // Function to find full sentence and highlight target words
        function createSentenceWithBoldWords(fullText, targetText, replacementText) {
            console.log(`üîç Looking for sentence containing: "${targetText}"`);

            // Split into proper sentences (more precise splitting)
            const sentences = fullText.split(/(?<=[.!?])\s+/)
                .filter(s => s.trim().length > 10) // Filter out very short fragments
                .map(s => s.trim());

            let containingSentence = '';

            // First pass: look for sentences containing the target word as a complete word
            for (let sentence of sentences) {
                const wordBoundaryRegex = new RegExp(`\\b${targetText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                if (wordBoundaryRegex.test(sentence)) {
                    // Prefer shorter, more focused sentences
                    if (!containingSentence || sentence.length < containingSentence.length) {
                        containingSentence = sentence;
                    }
                }
            }

            // Second pass: if no sentence found, try more flexible matching but limit length
            if (!containingSentence) {
                for (let sentence of sentences) {
                    if (sentence.toLowerCase().includes(targetText.toLowerCase()) && sentence.length < 200) {
                        containingSentence = sentence;
                        break;
                    }
                }
            }

            // Third pass: split differently if still not found
            if (!containingSentence) {
                const altSentences = fullText.split(/[.!?]+/)
                    .map(s => s.trim())
                    .filter(s => s.length > 10 && s.length < 300); // Reasonable sentence length

                for (let sentence of altSentences) {
                    const wordBoundaryRegex = new RegExp(`\\b${targetText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                    if (wordBoundaryRegex.test(sentence)) {
                        containingSentence = sentence;
                        // Add period if missing
                        if (!containingSentence.match(/[.!?]$/)) {
                            containingSentence += '.';
                        }
                        break;
                    }
                }
            }

            // Fallback: use a short context around the target word
            if (!containingSentence) {
                const targetIndex = fullText.toLowerCase().indexOf(targetText.toLowerCase());
                if (targetIndex >= 0) {
                    const start = Math.max(0, targetIndex - 50);
                    const end = Math.min(fullText.length, targetIndex + targetText.length + 50);
                    containingSentence = fullText.substring(start, end).trim() + '...';
                } else {
                    containingSentence = targetText;
                }
            }

            console.log(`‚úÖ Found containing sentence: "${containingSentence.substring(0, 100)}..."`);

            // Create current version with bold target words
            const targetRegex = new RegExp(`\\b${targetText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
            const currentSentence = containingSentence.replace(
                targetRegex,
                `<strong style="background: #FEF3C7; color: #92400E; padding: 2px 4px; border-radius: 3px;">$&</strong>`
            );

            // Create suggested version with bold replacement words
            const suggestedSentence = containingSentence.replace(
                targetRegex,
                `<strong style="background: #D1FAE5; color: #065F46; padding: 2px 4px; border-radius: 3px;">${replacementText}</strong>`
            );

            console.log(`üìù Current: "${currentSentence.substring(0, 100)}..."`);
            console.log(`‚ú® Suggested: "${suggestedSentence.substring(0, 100)}..."`);

            return {
                current: currentSentence,
                suggested: suggestedSentence,
                fullSentence: containingSentence
            };
        }

        // Enhanced tone analysis function
        async function runToneAnalysis() {
            console.log('üöÄ runToneAnalysis called');

            const textToAnalyze = document.getElementById('text-editor').value;
            console.log('üìù Text to analyze length:', textToAnalyze?.length || 0);

            if (!textToAnalyze || textToAnalyze.trim().length === 0) {
                console.log('‚ùå No text to analyze');
                alert('Please enter some text to analyze');
                return;
            }

            // Update UI to show loading
            const summaryElement = document.getElementById('analysis-summary');
            const recommendationsElement = document.getElementById('recommendations-list');

            console.log('üéØ Elements found:', {
                summaryElement: !!summaryElement,
                recommendationsElement: !!recommendationsElement
            });

            if (summaryElement) {
                summaryElement.textContent = 'Analyzing tone and generating recommendations...';
            }
            if (recommendationsElement) {
                recommendationsElement.innerHTML = '<div class="loading-indicator">üîÑ Analysis in progress...</div>';
            }

            try {
                console.log('üì° Making API request to /api/analyze/tone');
                const response = await fetch('/api/analyze/tone', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: textToAnalyze,
                        campaignProfile: null
                    })
                });

                console.log('üì® Response received:', response.status, response.ok);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                console.log('üìä Result received:', { success: result.success, hasAnalysis: !!result.analysis });

                if (!result.success) {
                    throw new Error(result.error || 'Tone analysis failed');
                }

                // Process and display results
                displayAnalysisResults(result.analysis, textToAnalyze);
                console.log('‚úÖ Analysis completed successfully');

            } catch (error) {
                console.error('‚ùå Tone analysis error:', error);
                if (summaryElement) {
                    summaryElement.textContent = `Analysis failed - ${error.message}`;
                }
                if (recommendationsElement) {
                    recommendationsElement.innerHTML = `
                        <div class="error-message">
                            <h3>‚ùå Tone Analysis Failed</h3>
                            <p><strong>Error:</strong> ${error.message}</p>
                        </div>
                    `;
                }
            }
        }

        // Global variable to store current recommendations for highlighting
        let currentRecommendations = [];

        // Global variables for dynamic scoring
        let initialScore = 0;
        let currentScore = 0;
        let maxPossibleScore = 100;
        let appliedRecommendations = new Set();
        let dismissedRecommendations = new Set();
        let isReAnalyzing = false;
        let lastReAnalysisTime = 0;

        // Dynamic scoring functions
        function calculateCurrentScore() {
            if (currentRecommendations.length === 0) return currentScore;

            const totalRecommendations = currentRecommendations.length;
            const appliedCount = getAppliedCount();
            const dismissedCount = getDismissedCount();
            const completedCount = appliedCount + dismissedCount;

            // Calculate improvement: each applied recommendation adds points
            const appliedBonus = appliedCount * (35 / totalRecommendations); // Up to 35 points for applying all
            const dismissedPenalty = dismissedCount * (5 / totalRecommendations); // Small penalty for dismissing

            // Calculate new score: start with initial + bonus - penalty
            const newScore = Math.min(maxPossibleScore, initialScore + appliedBonus - dismissedPenalty);

            console.log(`üìä Score calculation: initial=${initialScore}, applied=${appliedCount}, dismissed=${dismissedCount}, newScore=${newScore.toFixed(1)}`);

            return Math.round(newScore * 10) / 10; // Round to 1 decimal place
        }

        function updateScoreDisplay(recommendationCount = null, tone = null) {
            const summaryElement = document.getElementById('analysis-summary');
            if (!summaryElement) return;

            currentScore = calculateCurrentScore();
            const appliedCount = getAppliedCount();
            const totalCount = recommendationCount || currentRecommendations.length;
            const toneText = tone || 'Professional';

            // Show score improvement if any recommendations have been applied
            let scoreText;
            if (appliedCount > 0) {
                const improvement = (currentScore - initialScore).toFixed(1);
                const arrow = improvement > 0 ? '‚ÜóÔ∏è' : '';
                scoreText = `${currentScore}% ${arrow}(+${improvement})`;
            } else {
                scoreText = `${currentScore}%`;
            }

            const remainingCount = totalCount - appliedCount - getDismissedCount();
            summaryElement.textContent = `${remainingCount} recommendations remaining | Overall Score: ${scoreText} | Tone: ${toneText}`;
        }

        // Display analysis results with enhanced recommendations and alternatives
        function displayAnalysisResults(analysis, text) {
            const summaryElement = document.getElementById('analysis-summary');
            const recommendationsElement = document.getElementById('recommendations-list');

            // Enhance recommendations if there are too few
            const originalRecommendations = analysis.recommendations || [];
            currentRecommendations = enhanceRecommendations(originalRecommendations, text);

            console.log(`üìä Original recommendations: ${originalRecommendations.length}, Enhanced: ${currentRecommendations.length}`);

            // Initialize scoring system
            initialScore = analysis.overall_score?.score || analysis.overall_score || 65;
            currentScore = initialScore;
            const overallTone = analysis.overall_tone?.primary_tone || 'Neutral';
            const recommendationCount = currentRecommendations.length;

            // Update summary with dynamic score
            updateScoreDisplay(recommendationCount, overallTone);

            // Update issue count
            const issueCountElement = document.getElementById('issue-count');
            if (issueCountElement) {
                issueCountElement.textContent = `${recommendationCount} issues found`;
            }

            // Display recommendations
            if (recommendationCount === 0) {
                recommendationsElement.innerHTML = '<div class="loading-indicator">No recommendations at this time ‚úÖ</div>';
                return;
            }

            let html = '';
            currentRecommendations.forEach((rec, index) => {
                const alternatives = generateAlternatives(rec);
                const originalText = rec.examples && rec.examples.length > 0 ? rec.examples[0] : 'Selected text';

                html += `
                    <div class="recommendation" id="rec-${index}" onclick="expandRecommendation(${index})" style="cursor: pointer; border-left: 4px solid #4F46E5;">
                        <div class="recommendation-header">
                            <div class="recommendation-type">
                                ${getIssueIcon(rec.type)} ${rec.issue || rec.suggestion || rec.type}
                            </div>
                            <span class="recommendation-severity ${rec.priority || 'medium'}">${(rec.priority || 'medium').toUpperCase()}</span>
                        </div>

                        <div class="recommendation-details">
                            <div class="recommendation-issue">${rec.suggestion || 'Improvement needed for better tone and engagement'}</div>
                            <div class="recommendation-explanation">${rec.explanation || getExplanationForType(rec.type)}</div>

                            <div class="recommendation-context" id="context-${index}">
                                <strong>Current text:</strong> "${originalText}"
                            </div>


                            <div class="alternative-suggestions">
                                <h4>üí° Alternative Recommendations <span style="font-size: 0.8rem; color: #6B7280;">(Double-click to apply)</span></h4>
                                ${alternatives.map((alt, altIndex) => `
                                    <div class="suggestion-item ${altIndex === 0 ? 'selected' : ''}"
                                         onclick="selectAlternative(${index}, ${altIndex})"
                                         ondblclick="selectAndApplyAlternative(${index}, ${altIndex})"
                                         data-alt-index="${altIndex}">
                                        <div class="suggestion-label">${alt.label}</div>
                                        <div class="suggestion-text">"${alt.text}"</div>
                                    </div>
                                `).join('')}
                            </div>

                            <div class="recommendation-actions">
                                <button class="action-button apply" onclick="applyRecommendation(${index})">‚úÖ Apply Selected</button>
                                <button class="action-button secondary" onclick="dismissRecommendation(${index})">‚ùå Dismiss</button>
                            </div>
                        </div>
                    </div>
                `;
            });

            recommendationsElement.innerHTML = html;

            // Update recommendation contexts with full sentences and bold words
            updateRecommendationContexts();

            // Initialize progress indicator
            updateProgress();

            // Set up initial collapsed/expanded state and highlight first recommendation
            if (currentRecommendations.length > 0) {
                currentRecommendationIndex = 0;
                setTimeout(() => {
                    // Collapse all recommendations initially
                    currentRecommendations.forEach((_, index) => {
                        const recElement = document.getElementById(`rec-${index}`);
                        if (recElement) {
                            if (index === 0) {
                                recElement.classList.add('expanded');
                            } else {
                                recElement.classList.add('collapsed');
                            }
                        }
                    });

                    highlightInText(0);
                    addVisualHighlighting();
                }, 100);
            }
        }

        // Add visual highlighting to the text editor
        function addVisualHighlighting() {
            const editor = document.getElementById('text-editor');
            const overlay = document.getElementById('highlight-overlay');

            // Remove any existing highlighting first
            removeAllHighlighting();

            console.log(`‚ú® Visual highlighting system ready for ${currentRecommendations.length} recommendations`);

            // Set up overlay to mirror the textarea content
            updateOverlayContent();

            // Add a data attribute to track highlighted recommendations
            editor.setAttribute('data-highlighted-recommendations', currentRecommendations.length);
        }

        // Update the overlay content to match the textarea
        function updateOverlayContent() {
            const editor = document.getElementById('text-editor');
            const overlay = document.getElementById('highlight-overlay');

            if (overlay) {
                // Copy the text content to the overlay (initially without highlights)
                overlay.textContent = editor.value;
            }
        }

        // Remove all visual highlighting
        function removeAllHighlighting() {
            const editor = document.getElementById('text-editor');
            const overlay = document.getElementById('highlight-overlay');

            // Reset editor styling to default
            editor.style.borderColor = '#4F46E5';
            editor.style.boxShadow = '0 0 0 3px rgba(79, 70, 229, 0.1)';
            editor.classList.remove('highlighting');

            // Clear text selection
            if (editor.setSelectionRange) {
                editor.setSelectionRange(0, 0);
            }

            editor.removeAttribute('data-highlighted-recommendations');

            if (overlay) {
                overlay.innerHTML = '';
            }

            console.log('üßπ Cleared all highlighting');
        }

        // Create visual highlight for specific text
        function createVisualHighlight(textToHighlight) {
            const editor = document.getElementById('text-editor');

            if (!textToHighlight) {
                console.log('‚ùå No text to highlight provided');
                return;
            }

            console.log('üéØ Creating visual highlight for:', textToHighlight.substring(0, 50) + '...');

            const editorContent = editor.value;
            console.log('üìÑ Editor content length:', editorContent.length);
            console.log('üìÑ Looking for text in editor...');

            // Find the text to highlight
            let startIndex = -1;
            let endIndex = -1;

            if (textToHighlight.split(' ').length === 1) {
                // Single word - use word boundary matching
                const wordBoundaryRegex = new RegExp(`\\b${textToHighlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                const match = editorContent.match(wordBoundaryRegex);
                if (match) {
                    startIndex = editorContent.search(wordBoundaryRegex);
                    endIndex = startIndex + match[0].length;
                }
            } else {
                // Multi-word phrase - use exact matching
                console.log('üîç Searching for multi-word phrase...');
                startIndex = editorContent.indexOf(textToHighlight);
                if (startIndex !== -1) {
                    endIndex = startIndex + textToHighlight.length;
                    console.log('‚úÖ Found text at position:', startIndex, '-', endIndex);
                } else {
                    console.log('‚ùå Text not found with exact matching');
                    // Try case-insensitive search
                    const lowerEditor = editorContent.toLowerCase();
                    const lowerText = textToHighlight.toLowerCase();
                    startIndex = lowerEditor.indexOf(lowerText);
                    if (startIndex !== -1) {
                        endIndex = startIndex + textToHighlight.length;
                        console.log('‚úÖ Found text with case-insensitive search at:', startIndex, '-', endIndex);
                    } else {
                        console.log('‚ùå Text not found even with case-insensitive search');
                        console.log('üìù First 100 chars of editor:', editorContent.substring(0, 100));
                        console.log('üéØ Text we\'re looking for:', textToHighlight.substring(0, 100));
                    }
                }
            }

            if (startIndex >= 0 && endIndex > startIndex) {
                // Add highlighting class and select the text
                editor.classList.add('highlighting');
                editor.focus();
                editor.setSelectionRange(startIndex, endIndex);

                // Scroll to show the selection
                const lineHeight = 24;
                const lines = editorContent.substr(0, startIndex).split('\n').length;
                editor.scrollTop = Math.max(0, (lines - 5) * lineHeight);

                // Add a visual border pulse
                editor.style.borderColor = '#F59E0B';
                editor.style.boxShadow = '0 0 0 3px rgba(245, 158, 11, 0.3), 0 0 20px rgba(245, 158, 11, 0.2)';

                console.log(`‚ú® Highlighted "${textToHighlight}" at position ${startIndex}-${endIndex}`);

                // Remove highlighting class after animation
                setTimeout(() => {
                    editor.classList.remove('highlighting');
                    editor.style.borderColor = '#4F46E5';
                    editor.style.boxShadow = '0 0 0 3px rgba(79, 70, 229, 0.1)';
                }, 3000);
            } else {
                console.log(`‚ùå Could not find "${textToHighlight}" in editor text`);
            }
        }

        // Sync overlay scrolling with textarea
        function syncOverlayScroll() {
            const editor = document.getElementById('text-editor');
            const overlay = document.getElementById('highlight-overlay');

            if (overlay) {
                overlay.scrollTop = editor.scrollTop;
                overlay.scrollLeft = editor.scrollLeft;
            }
        }

        // Get different highlight colors for different recommendations
        function getHighlightColor(index) {
            const colors = ['#FEF3C7', '#DBEAFE', '#FCE7F3', '#D1FAE5', '#FEE2E2'];
            return colors[index % colors.length];
        }

        // Generic helper functions for text transformation
        function generateShorterSentences(text) {
            // Split long sentences and simplify
            return text.replace(/,\s+/g, '. ').replace(/\.\s+\./g, '.').substring(0, Math.max(50, text.length * 0.7));
        }

        function simplifyPoliticalLanguage(text) {
            const simplifications = {
                'announced': 'said',
                'declared': 'said',
                'Representative': 'Rep.',
                'former': 'past',
                'commitment': 'promise',
                'public service': 'serving people',
                'working hard': 'working',
                'the people of': 'people in'
            };

            let simplified = text;
            for (const [formal, simple] of Object.entries(simplifications)) {
                simplified = simplified.replace(new RegExp(formal, 'gi'), simple);
            }
            return simplified;
        }

        function addSpecificDetails(text) {
            // Add hypothetical specific details for demonstration
            if (text.toLowerCase().includes('video')) {
                return text.replace(/video/gi, '3-minute professionally-produced campaign video');
            }
            if (text.toLowerCase().includes('service')) {
                return text.replace(/service/gi, 'dedicated public service record spanning over [X] years');
            }
            return `${text} [Additional specific details would be added based on candidate background]`;
        }

        // Generate alternative recommendations for each issue
        function generateAlternatives(recommendation) {
            const type = recommendation.type;
            const originalText = recommendation.examples && recommendation.examples.length > 0 ? recommendation.examples[0] : '';

            console.log(`üîß Generating alternatives for type: ${type}, text: "${originalText}"`);

            // Handle document-specific formatting fixes
            if (recommendation.documentSpecific && recommendation.fix) {
                const currentText = document.getElementById('text-editor').value;
                const fixedText = recommendation.fix(currentText);
                return [
                    { label: 'üéØ Preferred: Apply Formatting Fix', text: fixedText },
                    { label: 'üìù Alternative: Manual Edit', text: 'Edit the formatting manually' },
                    { label: 'üîç Alternative: Keep Current', text: currentText }
                ];
            }

            // Generic pattern-based alternatives for common political content

            // Handle law enforcement/government service background
            if (originalText.toLowerCase().includes('former') && (originalText.toLowerCase().includes('officer') || originalText.toLowerCase().includes('agent'))) {
                return [
                    { label: 'üéØ Preferred: Clearer Language', text: generateShorterSentences(originalText) },
                    { label: 'üìù Alternative: Simpler Words', text: simplifyPoliticalLanguage(originalText) },
                    { label: 'üîç Alternative: More Specific', text: addSpecificDetails(originalText) }
                ];
            }

            // Handle media/video release announcements
            if (originalText.toLowerCase().includes('released') && (originalText.includes('"') || originalText.toLowerCase().includes('video'))) {
                return [
                    { label: 'üéØ Preferred: Clearer Language', text: generateShorterSentences(originalText) },
                    { label: 'üìù Alternative: Simpler Words', text: simplifyPoliticalLanguage(originalText) },
                    { label: 'üîç Alternative: More Specific', text: addSpecificDetails(originalText) }
                ];
            }



            // Apply smart verb replacement for common political verbs
            const commonVerbReplacements = {
                'announce': 'declare',
                'say': 'declare',
                'state': 'declare'
            };

            if (Object.keys(commonVerbReplacements).some(verb => originalText.toLowerCase().includes(verb))) {
                const decisiveReplacer = createSmartVerbReplacer({ 'announce': 'declare', 'say': 'declare', 'state': 'declare' });
                const actionReplacer = createSmartVerbReplacer({ 'announce': 'proclaim', 'say': 'proclaim', 'state': 'proclaim' });
                const personalReplacer = createSmartVerbReplacer({
                    'announce': { present: 'share with you', past: 'shared with you', gerund: 'sharing with you' },
                    'say': { present: 'tell you', past: 'told you', gerund: 'telling you' },
                    'state': { present: 'tell you', past: 'told you', gerund: 'telling you' }
                });

                return [
                    { label: 'üéØ Preferred: More Decisive', text: decisiveReplacer(originalText) },
                    { label: 'üí™ Alternative: Stronger Action', text: actionReplacer(originalText) },
                    { label: 'ü§ù Alternative: More Personal', text: personalReplacer(originalText) }
                ];
            }

            // Generate 3 genuinely different alternatives based on text transformation functions
            const alternative1 = makeClearer(originalText);
            const alternative2 = makeSimpler(originalText);
            const alternative3 = makeMoreSpecific(originalText);

            // Ensure alternatives are truly different - if they're the same, force different versions
            let alternatives = [
                { label: 'üéØ Preferred: Clearer Language', text: alternative1 },
                { label: 'üìù Alternative: Simpler Words', text: alternative2 },
                { label: 'üîç Alternative: More Specific', text: alternative3 }
            ];

            // Check if alternatives are identical and force different versions if needed
            if (alternative1 === alternative2 && alternative2 === alternative3) {
                console.log('‚ö†Ô∏è All alternatives identical, creating forced different versions');
                alternatives = [
                    { label: 'üéØ Preferred: Clearer Language', text: forceAlternative1(originalText) },
                    { label: 'üìù Alternative: Simpler Words', text: forceAlternative2(originalText) },
                    { label: 'üîç Alternative: More Specific', text: forceAlternative3(originalText) }
                ];
            }

            console.log(`üìù Generated alternatives:`, alternatives);
            return alternatives;
        }

        // Helper function for escaping regex special characters
        function escapeRegex(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // Get all common conjugations for a verb
        function getVerbConjugations(verb) {
            // Handle both simple verbs and complex phrases
            if (typeof verb === 'object') {
                return verb; // Already conjugated
            }

            // Common irregular verbs
            const irregularVerbs = {
                'announce': { present: 'announce', past: 'announced', gerund: 'announcing', thirdPerson: 'announces' },
                'say': { present: 'say', past: 'said', gerund: 'saying', thirdPerson: 'says' },
                'tell': { present: 'tell', past: 'told', gerund: 'telling', thirdPerson: 'tells' },
                'declare': { present: 'declare', past: 'declared', gerund: 'declaring', thirdPerson: 'declares' },
                'proclaim': { present: 'proclaim', past: 'proclaimed', gerund: 'proclaiming', thirdPerson: 'proclaims' },
                'state': { present: 'state', past: 'stated', gerund: 'stating', thirdPerson: 'states' },
                'release': { present: 'release', past: 'released', gerund: 'releasing', thirdPerson: 'releases' },
                'publish': { present: 'publish', past: 'published', gerund: 'publishing', thirdPerson: 'publishes' }
            };

            if (irregularVerbs[verb]) {
                return irregularVerbs[verb];
            }

            // Regular verb conjugation rules
            return {
                present: verb,
                past: verb.endsWith('e') ? verb + 'd' : verb + 'ed',
                gerund: verb.endsWith('e') ? verb.slice(0, -1) + 'ing' : verb + 'ing',
                thirdPerson: verb.endsWith('s') || verb.endsWith('sh') || verb.endsWith('ch') ? verb + 'es' : verb + 's'
            };
        }

        // General verb conjugation system - detects verbs and replaces with proper tense
        function createSmartVerbReplacer(verbMappings) {
            return function(text) {
                let result = text;

                // Process each verb mapping
                Object.entries(verbMappings).forEach(([sourceVerb, targetVerbs]) => {
                    // Handle different verb forms
                    const conjugations = getVerbConjugations(sourceVerb);
                    const targetConjugations = getVerbConjugations(targetVerbs.base || targetVerbs);

                    // Replace all forms while maintaining tense/person
                    Object.entries(conjugations).forEach(([form, pattern]) => {
                        if (pattern && targetConjugations[form]) {
                            const regex = new RegExp(`\\b${escapeRegex(pattern)}\\b`, 'gi');
                            result = result.replace(regex, targetConjugations[form]);
                        }
                    });
                });

                return result;
            };
        }

        // Text transformation functions with meaningful alternatives
        function makeMoreDecisive(text) {
            // Use general verb replacement system
            const verbReplacer = createSmartVerbReplacer({
                'announce': 'declare',
                'say': 'declare',
                'state': 'declare'
            });

            let result = verbReplacer(text);

            // General decisive language patterns
            const decisivePatterns = {
                'working hard': 'committed to delivering',
                'will be working': 'will deliver',
                'I plan to': 'I will',
                'I hope to': 'I will',
                'I will try to': 'I will',
                'might': 'will',
                'could': 'will',
                'should': 'will',
                'we must': 'we will',
                'we should': 'we will',
                'it would be good to': 'we will',
                'perhaps': 'certainly',
                'maybe': 'definitely',
                'trying to': 'committed to',
                'working to': 'delivering'
            };

            for (const [weak, strong] of Object.entries(decisivePatterns)) {
                const regex = new RegExp(`\\b${escapeRegex(weak)}\\b`, 'gi');
                result = result.replace(regex, strong);
            }
            return result;
        }

        function makeStrongerAction(text) {
            // Use general verb replacement system for action verbs
            const verbReplacer = createSmartVerbReplacer({
                'announce': 'proclaim',
                'say': 'proclaim',
                'state': 'proclaim',
                'help': 'champion',
                'support': 'champion',
                'assist': 'empower',
                'work': 'fight',
                'try': 'commit'
            });

            let result = verbReplacer(text);

            // General action-oriented language patterns
            const actionPatterns = {
                'working on': 'delivering',
                'focusing on': 'prioritizing',
                'trying to': 'committed to',
                'helping': 'ensuring',
                'supporting': 'championing',
                'assisting': 'empowering',
                'working hard': 'fighting tirelessly',
                'plan to': 'will',
                'hope to': 'will',
                'intend to': 'will',
                'attempting to': 'delivering',
                'seeking to': 'committed to'
            };

            for (const [weak, strong] of Object.entries(actionPatterns)) {
                const regex = new RegExp(`\\b${escapeRegex(weak)}\\b`, 'gi');
                result = result.replace(regex, strong);
            }
            return result;
        }

        function makeMorePersonal(text) {
            // Use general verb replacement system for personal language
            const verbReplacer = createSmartVerbReplacer({
                'announce': { present: 'share with you', past: 'shared with you', gerund: 'sharing with you' },
                'say': { present: 'tell you', past: 'told you', gerund: 'telling you' },
                'state': { present: 'tell you', past: 'told you', gerund: 'telling you' }
            });

            let result = verbReplacer(text);

            // General personal language patterns
            const personalPatterns = {
                'we must': 'I will personally ensure we',
                'it is important': 'I believe deeply',
                'should': 'will',
                'our country': 'the country I love',
                'the people': 'families like yours',
                'citizens': 'neighbors',
                'voters': 'friends and neighbors',
                'the public': 'you and your family',
                'Americans': 'people like you',
                'residents': 'neighbors',
                'this community': 'our shared home'
            };

            for (const [formal, personal] of Object.entries(personalPatterns)) {
                const regex = new RegExp(`\\b${escapeRegex(formal)}\\b`, 'gi');
                result = result.replace(regex, personal);
            }
            return result;
        }

        function makeClearer(text) {
            // Clean up the text first - remove any artifacts or corruption
            text = text.trim().replace(/\s+/g, ' ');

            // Use general verb replacement system for clarity
            const verbReplacer = createSmartVerbReplacer({
                'announce': { present: 'tell you', past: 'told you', gerund: 'telling you' },
                'state': { present: 'tell you', past: 'told you', gerund: 'telling you' },
                'utilize': 'use',
                'facilitate': 'help'
            });

            let result = verbReplacer(text);

            // General clarity patterns - remove jargon and complex phrases
            const clarityPatterns = {
                'in order to': 'to',
                'due to the fact that': 'because',
                'at this point in time': 'now',
                'at the present time': 'now',
                'in the event that': 'if',
                'for the purpose of': 'to',
                'with regard to': 'about',
                'in accordance with': 'following',
                'prior to': 'before',
                'subsequent to': 'after',
                'in the vicinity of': 'near',
                'in excess of': 'more than',
                'a majority of': 'most',
                'a number of': 'some',
                'at the conclusion of': 'after',
                'during the course of': 'during'
            };

            for (const [complex, simple] of Object.entries(clarityPatterns)) {
                const regex = new RegExp(`\\b${escapeRegex(complex)}\\b`, 'gi');
                result = result.replace(regex, simple);
            }

            // Break up very long sentences
            if (result.split(' ').length > 30) {
                // Find sentence breaks and split long sentences
                result = result.replace(/([.!?]\s*)([A-Z])/g, '$1\n$2');
                const sentences = result.split('\n');
                if (sentences.length > 1) {
                    result = sentences.slice(0, 2).join(' '); // Take first two sentences
                }
            }

            return result;
        }

        function makeSimpler(text) {
            // Clean up the text first
            text = text.trim().replace(/\s+/g, ' ');

            // Use general verb replacement system for simple language
            const verbReplacer = createSmartVerbReplacer({
                'announce': { present: 'say', past: 'said', gerund: 'saying' },
                'state': { present: 'say', past: 'said', gerund: 'saying' },
                'declare': { present: 'say', past: 'said', gerund: 'saying' },
                'release': { present: 'put out', past: 'put out', gerund: 'putting out' },
                'demonstrate': 'show',
                'utilize': 'use',
                'facilitate': 'help'
            });

            let result = verbReplacer(text);

            // General simple word replacements
            const simplePatterns = {
                'highlighting': 'showing',
                'commitment': 'promise',
                'reputation': 'record',
                'individual': 'person',
                'assistance': 'help',
                'opportunity': 'chance',
                'collaboration': 'working together',
                'implementation': 'doing',
                'achievement': 'success',
                'establishment': 'setting up',
                'participation': 'taking part',
                'communication': 'talking',
                'representative': 'person who speaks for',
                'legislation': 'laws',
                'administration': 'government'
            };

            for (const [complex, simple] of Object.entries(simplePatterns)) {
                const regex = new RegExp(`\\b${escapeRegex(complex)}\\b`, 'gi');
                result = result.replace(regex, simple);
            }
            return result;
        }

        function makeMoreSpecific(text) {
            // Clean up the text first
            text = text.trim().replace(/\s+/g, ' ');

            // Use general verb replacement system for specific language
            const verbReplacer = createSmartVerbReplacer({
                'announce': { present: 'officially declare', past: 'officially declared', gerund: 'officially declaring' },
                'say': { present: 'officially state', past: 'officially stated', gerund: 'officially stating' },
                'release': { present: 'publish', past: 'published', gerund: 'publishing' },
                'work': { present: 'actively work', past: 'actively worked', gerund: 'actively working' },
                'help': { present: 'directly assist', past: 'directly assisted', gerund: 'directly assisting' }
            });

            let result = verbReplacer(text);

            // General specificity patterns
            const specificPatterns = {
                'highlighting': 'specifically documenting',
                'commitment': 'decade-long commitment',
                'reputation': 'proven track record',
                'experience': 'extensive experience',
                'support': 'legislative support',
                'work': 'comprehensive work',
                'effort': 'sustained effort',
                'focus': 'laser focus',
                'plan': 'detailed plan',
                'vision': 'comprehensive vision',
                'goal': 'specific goal',
                'today': 'today at [specific time]',
                'recently': 'on [specific date]',
                'soon': 'within [specific timeframe]',
                'many': '[specific number of]',
                'several': '[specific number of]',
                'some': '[specific number of]'
            };

            for (const [vague, specific] of Object.entries(specificPatterns)) {
                const regex = new RegExp(`\\b${escapeRegex(vague)}\\b`, 'gi');
                result = result.replace(regex, specific);
            }

            // Add specific numbers where generic terms exist
            result = result.replace(/\byears?\b/gi, '[X] years');
            result = result.replace(/\bfamilies\b/gi, '[X] families');
            result = result.replace(/\bbusinesses\b/gi, '[X] businesses');
            result = result.replace(/\bpeople\b/gi, '[X] people');

            return result;
        }

        function makeMoreEngaging(text) {
            // Use general verb replacement system for engaging language
            const verbReplacer = createSmartVerbReplacer({
                'announce': 'proudly share',
                'say': 'share with enthusiasm',
                'state': 'proudly declare',
                'work': 'fight',
                'help': 'champion'
            });

            let result = verbReplacer(text);

            // General engaging language patterns
            const engagingPatterns = {
                'today': 'right now',
                'working hard': 'fighting every day',
                'will be': 'will absolutely be',
                'important': 'absolutely crucial',
                'helping': 'championing',
                'support': 'passionately support',
                'believe': 'know in my heart',
                'committed to': 'dedicated to'
            };

            for (const [bland, engaging] of Object.entries(engagingPatterns)) {
                const regex = new RegExp(`\\b${escapeRegex(bland)}\\b`, 'gi');
                result = result.replace(regex, engaging);
            }
            return result !== text ? result : `${text} with engaging tone`;
        }

        function addQuestion(text) {
            return `${text} - Are you ready to join me?`;
        }

        function addEmotion(text) {
            // Use general verb replacement system for emotional language
            const verbReplacer = createSmartVerbReplacer({
                'announce': { present: 'am thrilled to announce', past: 'was thrilled to announce', gerund: 'being thrilled to announce' },
                'say': { present: 'share with deep emotion', past: 'shared with deep emotion', gerund: 'sharing with deep emotion' },
                'state': { present: 'declare with passion', past: 'declared with passion', gerund: 'declaring with passion' },
                'work': { present: 'pour my heart into', past: 'poured my heart into', gerund: 'pouring my heart into' },
                'help': { present: 'am passionate about helping', past: 'was passionate about helping', gerund: 'being passionate about helping' }
            });

            let result = verbReplacer(text);

            // General emotional language patterns
            const emotionalPatterns = {
                'today': 'this historic day',
                'important': 'deeply meaningful',
                'believe': 'feel in my heart',
                'committed': 'passionately committed',
                'support': 'wholeheartedly support',
                'will': 'am determined to',
                'need': 'desperately need',
                'must': 'absolutely must'
            };

            for (const [neutral, emotional] of Object.entries(emotionalPatterns)) {
                const regex = new RegExp(`\\b${escapeRegex(neutral)}\\b`, 'gi');
                result = result.replace(regex, emotional);
            }
            return result !== text ? result : `${text} with emotional connection`;
        }

        function enhanceText(text) {
            return makeMoreDecisive(text);
        }

        function polishText(text) {
            return makeStrongerAction(text);
        }

        function refineText(text) {
            return makeMorePersonal(text);
        }

        // Forced different alternatives when other functions return identical text
        function forceAlternative1(text) {
            // Make it significantly shorter and more punchy
            if (text.length > 100) {
                // Break long sentences into short, impactful statements
                const sentences = text.split(/[.!?]+/).filter(s => s.trim());
                if (sentences.length > 0) {
                    const firstSentence = sentences[0].trim();
                    // Create a much shorter, punchier version
                    return firstSentence.split(',')[0] + '.';
                }
            }

            // Use strong, direct replacements
            const verbReplacer = createSmartVerbReplacer({
                'announce': 'declare',
                'say': 'state firmly',
                'state': 'assert',
                'work': 'fight',
                'help': 'champion'
            });

            let result = verbReplacer(text);

            // Aggressive shortening patterns
            const punchyPatterns = {
                'long family heritage statement': 'shorter family connection',
                'working hard': 'fighting',
                'trying to': 'will',
                'planning to': 'will',
                'hoping to': 'will',
                'seeking to': 'will',
                'I am proud to': 'I will',
                'it is important': 'we must'
            };

            for (const [wordy, direct] of Object.entries(punchyPatterns)) {
                const regex = new RegExp(escapeRegex(wordy), 'gi');
                result = result.replace(regex, direct);
            }
            return result;
        }

        function forceAlternative2(text) {
            // Make it very conversational and personal
            const verbReplacer = createSmartVerbReplacer({
                'announce': { present: 'want to share with you', past: 'shared with you', gerund: 'sharing with you' },
                'state': { present: 'need you to know', past: 'told you', gerund: 'telling you' },
                'declare': { present: 'want to say', past: 'said', gerund: 'saying' }
            });

            let result = verbReplacer(text);

            // Conversational transformations - make it much more personal
            const conversationalPatterns = {
                'formal background statement': 'personal family connection',
                'representative': 'your voice in Congress',
                'individuals': 'folks',
                'assistance': 'help',
                'commitment': 'promise to you',
                'fundamental': 'basic',
                'substantial': 'real',
                'significant': 'important',
                'working hard': 'giving everything I have',
                'support': 'stand with',
                'help': 'be there for',
                'serve': 'work for you'
            };

            for (const [formal, casual] of Object.entries(conversationalPatterns)) {
                const regex = new RegExp(escapeRegex(formal), 'gi');
                result = result.replace(regex, casual);
            }

            // Make it super conversational
            if (!result.includes('you') && result.length > 20) {
                result = `Let me tell you something: ${result}`;
            }

            return result;
        }

        function forceAlternative3(text) {
            // Make it more detailed and specific using general patterns
            const verbReplacer = createSmartVerbReplacer({
                'announce': { present: 'officially declare at a press conference', past: 'officially declared at a press conference', gerund: 'officially declaring at a press conference' },
                'support': { present: 'actively support with legislative action', past: 'actively supported with legislative action', gerund: 'actively supporting with legislative action' },
                'help': { present: 'provide direct assistance to', past: 'provided direct assistance to', gerund: 'providing direct assistance to' },
                'work': { present: 'work 18-hour days', past: 'worked 18-hour days', gerund: 'working 18-hour days' }
            });

            let result = verbReplacer(text);

            // General specificity patterns - these can be customized per region/context
            const specificPatterns = {
                'home state heritage': 'detailed local connection with specific demographics and policy plans',
                'today': 'today at 2:00 PM EST',
                'state': 'the state (with population details)',
                'people': 'constituents across the district',
                'Congress': 'the U.S. House of Representatives (435 members)',
                'working hard': 'dedicating 70+ hours per week across 15+ committees',
                'families': 'working families across the region'
            };

            for (const [vague, specific] of Object.entries(specificPatterns)) {
                const regex = new RegExp(`\\b${escapeRegex(vague)}\\b`, 'gi');
                result = result.replace(regex, specific);
            }

            // Add specific numbers/details if none exist
            if (!/\d/.test(result) && result.length > 50) {
                result = result.replace(/years?/gi, '12 years');
                result = result.replace(/families/gi, '150,000 families');
                result = result.replace(/businesses/gi, '2,500 small businesses');
            }

            return result;
        }

        // Get explanation for recommendation type
        function getExplanationForType(type) {
            const explanations = {
                'tone_improvement': 'Consider strengthening the tone to be more confident and decisive. Political communication benefits from clear, assertive language.',
                'clarity': 'This section could be clearer and more direct. Simplifying the language will help voters better understand your message.',
                'engagement': 'This area could be more engaging. Adding personal touches or questions can help connect with voters.',
                'professionalism': 'Consider adjusting the tone to be more professional while maintaining accessibility.',
                'confidence': 'This section could project more confidence. Strong, decisive language is important in political communication.'
            };
            return explanations[type] || 'Consider improving this section to enhance overall communication effectiveness.';
        }

        // Get icon for issue type
        function getIssueIcon(type) {
            const icons = {
                'tone_improvement': 'üé≠',
                'clarity': 'üí°',
                'engagement': 'üéØ',
                'professionalism': 'üëî',
                'confidence': 'üí™',
                'default': 'üìù'
            };
            return icons[type] || icons.default;
        }

        // Undo system
        function saveState() {
            const editor = document.getElementById('text-editor');
            undoStack.push(editor.value);
            if (undoStack.length > 20) {
                undoStack.shift();
            }
            document.getElementById('undo-button').disabled = undoStack.length <= 1;
        }

        function undoLastChange() {
            if (undoStack.length > 1) {
                undoStack.pop(); // Remove current state
                const previousState = undoStack[undoStack.length - 1];
                document.getElementById('text-editor').value = previousState;
                currentText = previousState;

                if (undoStack.length <= 1) {
                    document.getElementById('undo-button').disabled = true;
                }
            }
        }

        function enableUndo() {
            const undoButton = document.getElementById('undo-button');
            if (undoButton && undoStack.length > 0) {
                undoButton.disabled = false;
            }
        }

        // Interactive functions for recommendations
        function selectAlternative(recIndex, altIndex) {
            // Update visual selection
            const recElement = document.getElementById(`rec-${recIndex}`);
            const suggestions = recElement.querySelectorAll('.suggestion-item');
            suggestions.forEach(s => s.classList.remove('selected'));
            suggestions[altIndex].classList.add('selected');

            // Update the sentence context to reflect the newly selected alternative
            updateSingleRecommendationContext(recIndex);

            // Get alternatives for logging
            const alternatives = generateAlternatives(currentRecommendations[recIndex]);
            console.log(`‚úÖ Selected alternative ${altIndex} for recommendation ${recIndex}: "${alternatives[altIndex].text}"`);
        }

        function selectAndApplyAlternative(recIndex, altIndex) {
            console.log(`üéØ Double-click: Selecting and applying alternative ${altIndex} for recommendation ${recIndex}`);

            // First select the alternative
            selectAlternative(recIndex, altIndex);

            // Then apply it after a brief moment to show selection
            setTimeout(() => {
                applyRecommendation(recIndex);
            }, 150);
        }

        // Global variable to track current recommendation index
        let currentRecommendationIndex = 0;

        function applyRecommendation(recIndex) {
            const rec = currentRecommendations[recIndex];
            const selectedAltElement = document.querySelector(`#rec-${recIndex} .suggestion-item.selected`);
            const altIndex = parseInt(selectedAltElement.dataset.altIndex);
            const alternatives = generateAlternatives(rec);
            const selectedText = alternatives[altIndex].text;

            // Apply the change to the text editor
            const editor = document.getElementById('text-editor');

            // Handle document-specific formatting fixes (full text replacement)
            if (rec.documentSpecific && rec.fix && altIndex === 0) {
                console.log(`üîß Applying document-specific formatting fix`);
                editor.value = selectedText;
                editor.dispatchEvent(new Event('input'));
                console.log(`‚úÖ Full text replaced with formatted version`);

                // Mark as applied and continue to re-analysis
                appliedRecommendations.add(recIndex);
                updateProgressDisplay();
                calculateAndDisplayScore();
                reAnalyzeAndUpdateRecommendations();
                return;
            }

            const originalText = rec.examples && rec.examples.length > 0 ? rec.examples[0] : '';

            console.log(`üîß Applying recommendation ${recIndex}:`);
            console.log(`üìù Original text: "${originalText}"`);
            console.log(`‚ú® Replacement text: "${selectedText}"`);
            console.log(`üìÑ Editor contains original: ${editor.value.includes(originalText)}`);
            console.log(`üìÑ Selected text: "${selectedText}"`);

            // First, ensure we have valid text to replace
            if (!originalText || !originalText.trim()) {
                console.log(`‚ùå No original text to replace`);
                showNotification('No text specified for replacement', 'warning');
                return;
            }

            if (!selectedText || !selectedText.trim()) {
                console.log(`‚ùå No replacement text provided`);
                showNotification('No replacement text provided', 'warning');
                return;
            }

            if (originalText && originalText.trim() && editor.value.includes(originalText)) {
                // Perform the replacement with word boundary checking for single words
                const oldValue = editor.value;
                let newValue = oldValue;

                console.log(`üîß Attempting replacement: "${originalText}" ‚Üí "${selectedText}"`);

                if (originalText.split(' ').length === 1) {
                    // Single word - use word boundary replacement to avoid partial matches
                    const escapedOriginal = originalText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const wordBoundaryRegex = new RegExp(`\\b${escapedOriginal}\\b`, 'g');

                    console.log(`üìù Using word boundary regex: ${wordBoundaryRegex}`);

                    // Test if the regex finds matches
                    const matches = oldValue.match(wordBoundaryRegex);
                    console.log(`üîç Found ${matches ? matches.length : 0} matches`);

                    if (matches && matches.length > 0) {
                        newValue = oldValue.replace(wordBoundaryRegex, selectedText);
                    } else {
                        console.log(`‚ùå No word boundary matches found for "${originalText}"`);
                        // Try case-insensitive match
                        const caseInsensitiveRegex = new RegExp(`\\b${escapedOriginal}\\b`, 'gi');
                        newValue = oldValue.replace(caseInsensitiveRegex, selectedText);
                    }
                } else {
                    // Multi-word phrase - use exact replacement
                    console.log(`üìù Using exact replacement for phrase: "${originalText}"`);
                    newValue = oldValue.replace(originalText, selectedText);
                }

                // Verify the replacement actually happened
                if (newValue !== oldValue) {
                    console.log(`‚úÖ Replacement successful - text changed`);
                    editor.value = newValue;
                } else {
                    console.log(`‚ùå Replacement failed - text unchanged`);
                    console.log(`üìÑ Trying fallback: case-insensitive replacement`);

                    // Fallback: try case-insensitive replacement
                    const escapedOriginal = originalText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const fallbackRegex = new RegExp(escapedOriginal, 'gi');
                    newValue = oldValue.replace(fallbackRegex, selectedText);

                    if (newValue !== oldValue) {
                        console.log(`‚úÖ Fallback replacement successful`);
                        editor.value = newValue;
                    } else {
                        console.log(`‚ùå All replacement attempts failed`);
                        showNotification(`Could not replace "${originalText}". Text may have been modified.`, 'warning');
                        return;
                    }
                }

                // Verify the replacement worked
                if (editor.value !== oldValue) {
                    saveState();
                    console.log(`‚úÖ Text successfully replaced in editor`);

                    // Show success message
                    showNotification(`Applied: ${alternatives[altIndex].label}`, 'success');

                    // Mark recommendation as applied
                    markRecommendationAsApplied(recIndex);

                    // Important: Update all remaining recommendations to search for text in the updated content
                    updateRemainingRecommendations(editor.value);

                    // Re-analyze the text after successful edit to get fresh recommendations
                    console.log('üîÑ Re-analyzing text after edit to get fresh recommendations...');
                    setTimeout(() => {
                        reAnalyzeAndUpdateRecommendations();
                    }, 1000);
                } else {
                    console.log(`‚ùå Text replacement failed - editor content unchanged`);
                    showNotification('Text replacement failed. Please check and apply manually.', 'warning');
                }
            } else {
                console.log(`‚ùå Cannot replace: originalText="${originalText}", found=${editor.value.includes(originalText)}`);
                console.log(`üìÑ First 200 chars of editor: "${editor.value.substring(0, 200)}"`);

                // Try to find a close match
                const words = originalText.split(' ');
                if (words.length > 1) {
                    const firstWord = words[0];
                    const lastWord = words[words.length - 1];
                    console.log(`üîç Searching for partial matches: "${firstWord}" ... "${lastWord}"`);
                }

                showNotification('Could not locate exact text to replace. Text may have been modified.', 'warning');

                // Still mark as applied but with warning
                markRecommendationAsApplied(recIndex);

                // Re-analyze even after failed replacement to get fresh recommendations
                console.log('üîÑ Re-analyzing after failed replacement to get fresh recommendations...');
                setTimeout(() => {
                    reAnalyzeAndUpdateRecommendations();
                }, 1000);
            }
        }

        // Dynamic re-analysis function to get fresh recommendations after edits
        async function reAnalyzeAndUpdateRecommendations() {
            // Prevent multiple simultaneous re-analyses
            if (isReAnalyzing) {
                console.log('‚è≥ Re-analysis already in progress, skipping...');
                return;
            }

            // Throttle re-analysis to prevent infinite loops (minimum 3 seconds between calls)
            const now = Date.now();
            if (now - lastReAnalysisTime < 3000) {
                console.log('‚è±Ô∏è Re-analysis throttled, waiting for cooldown...');
                return;
            }

            const editor = document.getElementById('text-editor');
            const currentText = editor.value;

            if (!currentText || currentText.trim().length < 50) {
                console.log('‚ùå Text too short for re-analysis');
                showNotification('Text too short for analysis. Please add more content.', 'warning');
                return;
            }

            isReAnalyzing = true;
            lastReAnalysisTime = now;

            try {
                console.log('üì° Re-running tone analysis on modified text...');

                // Show loading state
                const summaryElement = document.getElementById('analysis-summary');
                const recommendationsElement = document.getElementById('recommendations-list');

                if (summaryElement) {
                    summaryElement.textContent = 'Re-analyzing text for fresh recommendations...';
                }
                if (recommendationsElement) {
                    recommendationsElement.innerHTML = '<div class="loading-indicator">üîÑ Updating recommendations...</div>';
                }

                // Call the tone analysis API with the current text
                const response = await fetch('/api/analyze/tone', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: currentText,
                        campaignProfile: null
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.error || 'Re-analysis failed');
                }

                console.log('‚úÖ Re-analysis completed, updating UI with fresh recommendations');

                // Update the global recommendations with fresh data
                currentRecommendations = result.analysis ? enhanceRecommendations(result.analysis) : [];

                // Reset applied/dismissed tracking for new recommendations
                appliedRecommendations.clear();
                dismissedRecommendations.clear();

                // Re-display with fresh recommendations
                displayAnalysisResults(result.analysis);

                // Auto-expand the first available recommendation
                if (currentRecommendations.length > 0) {
                    setTimeout(() => {
                        expandRecommendation(0);
                    }, 500);
                }

                showNotification('‚úÖ Recommendations updated based on current text', 'success');

            } catch (error) {
                console.error('‚ùå Re-analysis error:', error);
                showNotification(`Re-analysis failed: ${error.message}`, 'error');

                // If re-analysis fails, just show completion - don't continue with stale recommendations
                setTimeout(() => {
                    console.log('üèÅ Re-analysis failed, checking if all recommendations are complete...');
                    checkAndShowCompletion();
                }, 1000);
            } finally {
                // Reset the re-analysis flag
                isReAnalyzing = false;
                console.log('üîì Re-analysis lock released');
            }
        }

        // Global state to prevent infinite loops
        let currentlyExpandedRec = null;
        let isExpanding = false;

        // Expand/collapse recommendation management
        function expandRecommendation(recIndex) {
            // Prevent infinite loops and rapid clicking
            if (isExpanding || currentlyExpandedRec === recIndex) {
                console.log(`üö´ Already expanding/expanded recommendation ${recIndex}, ignoring`);
                return;
            }

            isExpanding = true;
            console.log(`üéØ Starting expansion of recommendation ${recIndex}`);

            // Note: Don't clear highlighting when expanding - let it persist until action is taken

            // Collapse all other recommendations
            currentRecommendations.forEach((_, index) => {
                const recElement = document.getElementById(`rec-${index}`);
                if (recElement && index !== recIndex) {
                    recElement.classList.remove('expanded');
                    recElement.classList.add('collapsed');
                }
            });

            // Expand the clicked recommendation
            const targetElement = document.getElementById(`rec-${recIndex}`);
            if (targetElement) {
                targetElement.classList.remove('collapsed');
                targetElement.classList.add('expanded');

                // Always highlight the text for this recommendation
                setTimeout(() => {
                    console.log(`üéØ Expanding recommendation ${recIndex}, triggering highlight`);
                    highlightInText(recIndex);

                    // Force highlighting even if text search fails
                    const editor = document.getElementById('text-editor');
                    if (editor) {
                        editor.focus();
                        // Add visual emphasis regardless of text matching
                        editor.style.borderColor = '#F59E0B';
                        editor.style.boxShadow = '0 0 0 3px rgba(245, 158, 11, 0.3), 0 0 20px rgba(245, 158, 11, 0.2)';
                        editor.classList.add('highlighting');
                    }
                    // Reset state after expansion is complete
                    currentlyExpandedRec = recIndex;
                    isExpanding = false;
                    console.log(`‚úÖ Completed expansion of recommendation ${recIndex}`);
                }, 100); // Small delay to ensure UI updates

                currentRecommendationIndex = recIndex;
            }
        }

        function markRecommendationAsApplied(recIndex) {
            const recElement = document.getElementById(`rec-${recIndex}`);
            if (recElement) {
                // Mark as applied with visual feedback
                recElement.style.borderLeft = '4px solid #059669';
                recElement.style.backgroundColor = '#F0FDF4';
                recElement.style.opacity = '0.7'; // Mark as processed
                recElement.classList.remove('expanded');
                recElement.classList.add('collapsed');

                // Add a data attribute to track this as applied
                recElement.setAttribute('data-status', 'applied');

                // Update the header to show it's applied
                const typeElement = recElement.querySelector('.recommendation-type');
                if (typeElement) {
                    typeElement.innerHTML = '‚úÖ ' + typeElement.innerHTML.replace(/^[^a-zA-Z]*/, '');
                }

                // Disable click handler for applied recommendations
                recElement.onclick = null;
                recElement.style.cursor = 'default';
                recElement.style.pointerEvents = 'none';

                // Clear the highlighting for this recommendation since it's been applied
                removeAllHighlighting();

                console.log(`‚úÖ Marked recommendation ${recIndex} as applied`);

                // Update score display to show improvement
                updateScoreDisplay();
            }
        }

        // Check if all recommendations are complete and show completion screen
        function checkAndShowCompletion() {
            const totalCount = currentRecommendations.length;

            // Check if all recommendations are processed
            let allCompleted = true;
            for (let i = 0; i < totalCount; i++) {
                const recElement = document.getElementById(`rec-${i}`);
                const status = recElement?.getAttribute('data-status');

                if (status !== 'applied' && status !== 'dismissed') {
                    allCompleted = false;
                    break;
                }
            }

            if (allCompleted) {
                // All recommendations have been processed
                console.log(`üéâ All recommendations completed`);

                // Calculate final score
                currentScore = calculateCurrentScore();

                showNotification(`üéâ All ${totalCount} recommendations processed! Great work!`, 'success');

                // Update the summary
                const summaryElement = document.getElementById('analysis-summary');
                if (summaryElement) {
                    summaryElement.textContent = `üéâ All ${totalCount} recommendations processed successfully!`;
                }

                // Update issue count
                const issueCountElement = document.getElementById('issue-count');
                if (issueCountElement) {
                    issueCountElement.textContent = '0 issues remaining';
                }

                // Show completion message in recommendations list
                const recommendationsElement = document.getElementById('recommendations-list');
                if (recommendationsElement) {
                    recommendationsElement.innerHTML = `
                        <div class="completion-message">
                            <div class="completion-icon">üéâ</div>
                            <h3>All Recommendations Completed!</h3>
                            <p>Great work! You've successfully processed all ${totalCount} editorial recommendations.</p>
                            <div class="completion-stats">
                                <div class="stat">
                                    <strong>${totalCount}</strong>
                                    <span>Recommendations</span>
                                </div>
                                <div class="stat">
                                    <strong>100%</strong>
                                    <span>Complete</span>
                                </div>
                                <div class="stat">
                                    <strong>${currentScore}%</strong>
                                    <span>Final Score</span>
                                </div>
                                <div class="stat">
                                    <strong>+${(currentScore - initialScore).toFixed(1)}</strong>
                                    <span>Improved</span>
                                </div>
                            </div>
                            <button onclick="rerunAnalysis()" class="action-button">üîÑ Analyze Again</button>
                        </div>
                    `;
                }

                // Update progress bar to show completion
                const progressIndicator = document.getElementById('progress-indicator');
                if (progressIndicator) {
                    const progressText = document.getElementById('progress-text');
                    const progressBar = document.getElementById('progress-bar');
                    progressText.textContent = `üéâ All ${totalCount} completed!`;
                    progressBar.style.width = '100%';
                }

                return true; // All complete
            }

            return false; // Not all complete
        }

        function moveToNextRecommendation(appliedIndex) {
            console.log(`üîÑ Moving from recommendation ${appliedIndex} to next available`);

            // Update progress first
            updateProgress();

            // Find the next available recommendation in sequential order
            let nextIndex = -1;

            // Start looking from the index after the applied one
            for (let i = appliedIndex + 1; i < currentRecommendations.length; i++) {
                const recElement = document.getElementById(`rec-${i}`);
                const status = recElement?.getAttribute('data-status');

                console.log(`Checking rec-${i}: status="${status}", opacity=${recElement?.style.opacity}`);

                // Check if recommendation is available (not applied, not dismissed)
                if (recElement &&
                    status !== 'applied' &&
                    status !== 'dismissed' &&
                    recElement.style.pointerEvents !== 'none') {
                    nextIndex = i;
                    console.log(`‚úÖ Found next available recommendation: ${nextIndex}`);
                    break;
                }
            }

            // If no recommendations found after the applied one, look before it
            if (nextIndex === -1) {
                for (let i = 0; i < appliedIndex; i++) {
                    const recElement = document.getElementById(`rec-${i}`);
                    const status = recElement?.getAttribute('data-status');

                    console.log(`Checking earlier rec-${i}: status="${status}", opacity=${recElement?.style.opacity}`);

                    if (recElement &&
                        status !== 'applied' &&
                        status !== 'dismissed' &&
                        recElement.style.pointerEvents !== 'none') {
                        nextIndex = i;
                        console.log(`‚úÖ Found earlier available recommendation: ${nextIndex}`);
                        break;
                    }
                }
            }

            if (nextIndex !== -1) {
                // Expand and highlight the next recommendation
                console.log(`üéØ Moving to recommendation ${nextIndex}`);

                // Use a timeout to allow the collapse animation to complete first
                setTimeout(() => {
                    // Clear old highlighting first
                    removeAllHighlighting();

                    // Reset expansion state to allow new expansion
                    currentlyExpandedRec = null;
                    isExpanding = false;

                    // Then expand and highlight the next recommendation
                    expandRecommendation(nextIndex);

                    // Scroll to the next recommendation card
                    const nextRecElement = document.getElementById(`rec-${nextIndex}`);
                    if (nextRecElement) {
                        nextRecElement.scrollIntoView({
                            behavior: 'smooth',
                            block: 'center'
                        });
                    }

                    showNotification(`Moving to recommendation ${nextIndex + 1} of ${currentRecommendations.length}`, 'info');
                }, 300); // Small delay for smooth animation

                currentRecommendationIndex = nextIndex;
            } else {
                // All recommendations have been processed
                console.log(`üéâ All recommendations completed`);
                const totalCount = currentRecommendations.length;

                // Calculate final score
                currentScore = calculateCurrentScore();

                showNotification(`üéâ All ${totalCount} recommendations processed! Great work!`, 'success');

                // Update the summary
                const summaryElement = document.getElementById('analysis-summary');
                if (summaryElement) {
                    summaryElement.textContent = `üéâ All ${totalCount} recommendations processed successfully!`;
                }

                // Update issue count
                const issueCountElement = document.getElementById('issue-count');
                if (issueCountElement) {
                    issueCountElement.textContent = '0 issues remaining';
                }

                // Show completion message in recommendations list
                const recommendationsElement = document.getElementById('recommendations-list');
                if (recommendationsElement) {
                    recommendationsElement.innerHTML = `
                        <div class="completion-message">
                            <div class="completion-icon">üéâ</div>
                            <h3>All Recommendations Completed!</h3>
                            <p>Great work! You've successfully processed all ${totalCount} editorial recommendations.</p>
                            <div class="completion-stats">
                                <div class="stat">
                                    <strong>${totalCount}</strong>
                                    <span>Recommendations</span>
                                </div>
                                <div class="stat">
                                    <strong>100%</strong>
                                    <span>Complete</span>
                                </div>
                                <div class="stat">
                                    <strong>${currentScore}%</strong>
                                    <span>Final Score</span>
                                </div>
                                <div class="stat">
                                    <strong>+${(currentScore - initialScore).toFixed(1)}</strong>
                                    <span>Improved</span>
                                </div>
                            </div>
                            <button onclick="rerunAnalysis()" class="action-button">üîÑ Analyze Again</button>
                        </div>
                    `;
                }

                // Update progress bar to show completion
                const progressIndicator = document.getElementById('progress-indicator');
                if (progressIndicator) {
                    const progressText = document.getElementById('progress-text');
                    const progressBar = document.getElementById('progress-bar');
                    progressText.textContent = `üéâ All ${totalCount} completed!`;
                    progressBar.style.width = '100%';
                }
            }
        }

        // Update recommendation contexts with full sentences and bold words
        function updateRecommendationContexts() {
            const editor = document.getElementById('text-editor');
            if (!editor) return;

            const fullText = editor.value;

            currentRecommendations.forEach((rec, index) => {
                updateSingleRecommendationContext(index, fullText);
            });
        }

        // Update a single recommendation's context based on currently selected alternative
        function updateSingleRecommendationContext(recIndex, fullText = null) {
            const editor = document.getElementById('text-editor');
            if (!editor) return;

            if (!fullText) fullText = editor.value;

            const contextElement = document.getElementById(`context-${recIndex}`);
            if (!contextElement) return;

            const rec = currentRecommendations[recIndex];
            const originalText = rec.examples && rec.examples.length > 0 ? rec.examples[0] : '';
            if (!originalText) return;

            // Get the currently selected alternative
            const selectedElement = document.querySelector(`#rec-${recIndex} .suggestion-item.selected`);
            const selectedIndex = selectedElement ? parseInt(selectedElement.dataset.altIndex) : 0;

            const alternatives = generateAlternatives(rec);
            const selectedText = alternatives[selectedIndex]?.text || alternatives[0]?.text || originalText;

            console.log(`üîÑ Updating context for rec ${recIndex} with selected alternative: "${selectedText}"`);

            // Create sentence context with bold words
            const sentenceData = createSentenceWithBoldWords(fullText, originalText, selectedText);

            // Update the context display
            contextElement.innerHTML = `
                <div style="margin-bottom: 0.8rem;">
                    <strong style="color: #DC2626;">üìù Current:</strong><br>
                    <span style="font-size: 0.95rem; line-height: 1.4; background: #FEF3C7; padding: 8px; border-radius: 6px; display: block; margin-top: 4px;">${sentenceData.current}</span>
                </div>
                <div>
                    <strong style="color: #059669;">‚ú® Suggested:</strong><br>
                    <span style="font-size: 0.95rem; line-height: 1.4; background: #D1FAE5; padding: 8px; border-radius: 6px; display: block; margin-top: 4px; cursor: pointer;"
                          ondblclick="applyRecommendation(${recIndex})"
                          title="Double-click to apply this suggestion">${sentenceData.suggested}</span>
                </div>
            `;
        }

        // Update progress indicator
        function updateProgress() {
            const totalCount = currentRecommendations.length;
            let completedCount = 0;

            // Count applied and dismissed recommendations using data attributes
            for (let i = 0; i < totalCount; i++) {
                const recElement = document.getElementById(`rec-${i}`);
                const status = recElement?.getAttribute('data-status');
                if (status === 'applied' || status === 'dismissed') {
                    completedCount++;
                }
            }

            // Update progress bar
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            const progressIndicator = document.getElementById('progress-indicator');

            if (progressBar && progressText && progressIndicator) {
                const percentage = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;
                progressBar.style.width = `${percentage}%`;
                progressText.textContent = `${completedCount} of ${totalCount} completed`;

                // Show progress indicator when there are recommendations
                if (totalCount > 0) {
                    progressIndicator.style.display = 'block';
                }
            }

            console.log(`üìä Progress: ${completedCount}/${totalCount} (${Math.round((completedCount / totalCount) * 100)}%) - Applied: ${getAppliedCount()}, Dismissed: ${getDismissedCount()}`);
        }

        // Helper functions to count specific statuses
        function getAppliedCount() {
            let count = 0;
            for (let i = 0; i < currentRecommendations.length; i++) {
                const recElement = document.getElementById(`rec-${i}`);
                if (recElement?.getAttribute('data-status') === 'applied') {
                    count++;
                }
            }
            return count;
        }

        function getDismissedCount() {
            let count = 0;
            for (let i = 0; i < currentRecommendations.length; i++) {
                const recElement = document.getElementById(`rec-${i}`);
                if (recElement?.getAttribute('data-status') === 'dismissed') {
                    count++;
                }
            }
            return count;
        }

        function highlightInText(recIndex) {
            const rec = currentRecommendations[recIndex];
            const editor = document.getElementById('text-editor');
            const originalText = rec.examples && rec.examples.length > 0 ? rec.examples[0] : '';

            console.log(`üîç Highlighting recommendation ${recIndex}: "${originalText}"`);
            console.log(`üìã Full recommendation object:`, rec);
            console.log(`üìÑ Editor contains text: ${editor.value.includes(originalText)}`);
            console.log(`üìä Editor text length: ${editor.value.length}, searching for: "${originalText}" (length: ${originalText.length})`);

            if (originalText && editor.value.includes(originalText)) {
                // For single words, ensure we're matching complete words only
                let startIndex = -1;
                let endIndex = -1;

                if (originalText.split(' ').length === 1) {
                    // Single word - use word boundary matching
                    const wordBoundaryRegex = new RegExp(`\\b${originalText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                    const match = editor.value.match(wordBoundaryRegex);
                    if (match) {
                        startIndex = editor.value.search(wordBoundaryRegex);
                        endIndex = startIndex + match[0].length;
                    }
                } else {
                    // Multi-word phrase - use exact matching
                    startIndex = editor.value.indexOf(originalText);
                    endIndex = startIndex + originalText.length;
                }

                if (startIndex >= 0 && endIndex > startIndex) {
                    // Force focus and clear any existing selection first
                    editor.blur();
                    setTimeout(() => {
                        editor.focus();
                        editor.setSelectionRange(startIndex, endIndex);

                        // Force the selection to be visible by adding a delay
                        setTimeout(() => {
                            editor.setSelectionRange(startIndex, endIndex);
                            console.log(`üéØ FORCED SELECTION: "${editor.value.substring(startIndex, endIndex)}" at ${startIndex}-${endIndex}`);
                        }, 100);
                    }, 50);

                    // Enhanced scrolling to center the text on screen
                    const lineHeight = 24; // Approximate line height
                    const lines = editor.value.substr(0, startIndex).split('\n').length;
                    const editorHeight = editor.clientHeight;
                    const linesVisible = Math.floor(editorHeight / lineHeight);
                    const centerOffset = Math.floor(linesVisible / 2);

                    // Scroll to center the highlighted text in the middle of the visible area
                    const targetScrollTop = Math.max(0, (lines - centerOffset) * lineHeight);
                    editor.scrollTop = targetScrollTop;

                    console.log(`üìç Centering highlight: line ${lines}, visible lines ${linesVisible}, centering with offset ${centerOffset}`);

                    // Create visual highlight overlay
                    createVisualHighlight(originalText);

                    // Update visual highlighting on recommendation cards
                    updateRecommendationHighlight(recIndex);

                    // Show notification with full text being highlighted
                    const displayText = originalText.length > 50 ?
                        originalText.substring(0, 50) + '...' :
                        originalText;
                    showNotification(`Highlighting: "${displayText}"`, 'info');

                    // Add persistent visual emphasis to the editor
                    editor.style.borderColor = '#F59E0B';
                    editor.style.boxShadow = '0 0 0 3px rgba(245, 158, 11, 0.3), 0 0 20px rgba(245, 158, 11, 0.2)';
                    editor.classList.add('highlighting');

                    // Add temporary background highlighting to make selection even more visible
                    const highlightStyle = document.createElement('style');
                    highlightStyle.id = 'temp-highlight-style';
                    highlightStyle.textContent = `
                        #text-editor::selection {
                            background-color: #F59E0B !important;
                            color: white !important;
                        }
                        #text-editor::-moz-selection {
                            background-color: #F59E0B !important;
                            color: white !important;
                        }
                    `;
                    document.head.appendChild(highlightStyle);

                    // Remove the style after 10 seconds
                    setTimeout(() => {
                        const style = document.getElementById('temp-highlight-style');
                        if (style) style.remove();
                    }, 10000);

                    // Force Grammarly to not interfere with selection
                    editor.setAttribute('data-grammarly-disable', 'true');

                    // Create a more visible highlight notification
                    const highlightNotification = document.createElement('div');
                    highlightNotification.style.cssText = `
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: #F59E0B;
                        color: white;
                        padding: 20px 30px;
                        border-radius: 12px;
                        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                        z-index: 10000;
                        font-family: system-ui;
                        font-size: 18px;
                        font-weight: bold;
                        text-align: center;
                        animation: pulse 2s infinite;
                    `;
                    highlightNotification.innerHTML = `
                        üéØ HIGHLIGHTING: "${originalText}"<br>
                        <small style="font-size: 14px; opacity: 0.9;">Position ${startIndex}-${endIndex} ‚Ä¢ Text is selected in editor</small>
                    `;
                    document.body.appendChild(highlightNotification);

                    // Remove the prominent notification after 4 seconds
                    setTimeout(() => {
                        if (highlightNotification.parentNode) {
                            highlightNotification.parentNode.removeChild(highlightNotification);
                        }
                    }, 4000);

                    // Keep highlight visible until next recommendation is clicked
                    // Remove automatic timeout to keep highlighting persistent

                    console.log(`‚úÖ Successfully highlighted "${originalText}" at position ${startIndex}-${endIndex}`);
                } else {
                    console.log(`‚ùå Could not find exact word boundary match for "${originalText}"`);
                    showNotification('Could not locate exact text for highlighting', 'warning');
                    updateRecommendationHighlight(recIndex);
                }

            } else {
                console.log(`‚ùå Could not find "${originalText}" in editor text`);
                console.log(`üìã Original text: "${originalText}"`);
                console.log(`üìÑ Editor text empty: ${!editor.value}`);
                console.log(`üìÑ Editor text length: ${editor.value.length}`);
                console.log(`üìÑ First 200 chars of editor: "${editor.value.substring(0, 200)}"`);

                // Try case-insensitive search
                const caseInsensitiveMatch = editor.value.toLowerCase().includes(originalText.toLowerCase());
                console.log(`üîç Case-insensitive match: ${caseInsensitiveMatch}`);

                // Try to find partial matches for better user experience
                const words = originalText.split(' ');
                if (words.length > 2) {
                    const firstFewWords = words.slice(0, 3).join(' ');
                    const lastFewWords = words.slice(-3).join(' ');

                    if (editor.value.includes(firstFewWords)) {
                        const startIndex = editor.value.indexOf(firstFewWords);
                        editor.focus();
                        editor.setSelectionRange(startIndex, startIndex + firstFewWords.length);

                        // Center the partial match too
                        const lineHeight = 24;
                        const lines = editor.value.substr(0, startIndex).split('\n').length;
                        const editorHeight = editor.clientHeight;
                        const linesVisible = Math.floor(editorHeight / lineHeight);
                        const centerOffset = Math.floor(linesVisible / 2);
                        const targetScrollTop = Math.max(0, (lines - centerOffset) * lineHeight);
                        editor.scrollTop = targetScrollTop;

                        // Add visual emphasis
                        editor.style.borderColor = '#F59E0B';
                        editor.style.boxShadow = '0 0 0 3px rgba(245, 158, 11, 0.3)';

                        showNotification(`Found partial match: "${firstFewWords}"`, 'warning');
                        updateRecommendationHighlight(recIndex);
                        return;
                    } else if (editor.value.includes(lastFewWords)) {
                        const startIndex = editor.value.indexOf(lastFewWords);
                        editor.focus();
                        editor.setSelectionRange(startIndex, startIndex + lastFewWords.length);

                        // Center the partial match too
                        const lineHeight = 24;
                        const lines = editor.value.substr(0, startIndex).split('\n').length;
                        const editorHeight = editor.clientHeight;
                        const linesVisible = Math.floor(editorHeight / lineHeight);
                        const centerOffset = Math.floor(linesVisible / 2);
                        const targetScrollTop = Math.max(0, (lines - centerOffset) * lineHeight);
                        editor.scrollTop = targetScrollTop;

                        // Add visual emphasis
                        editor.style.borderColor = '#F59E0B';
                        editor.style.boxShadow = '0 0 0 3px rgba(245, 158, 11, 0.3)';

                        showNotification(`Found partial match: "${lastFewWords}"`, 'warning');
                        updateRecommendationHighlight(recIndex);
                        return;
                    }
                }

                showNotification('Could not locate exact text in editor. Text may have been modified.', 'warning');
                updateRecommendationHighlight(recIndex);
            }
        }

        // Update visual highlighting on recommendation cards
        function updateRecommendationHighlight(activeIndex) {
            currentRecommendations.forEach((_, index) => {
                const recElement = document.getElementById(`rec-${index}`);
                if (recElement) {
                    if (index === activeIndex) {
                        recElement.style.borderLeft = '4px solid #F59E0B';
                        recElement.style.backgroundColor = '#FEF3C7';
                    } else {
                        recElement.style.borderLeft = '4px solid #4F46E5';
                        recElement.style.backgroundColor = '';
                    }
                }
            });
        }

        function dismissRecommendation(recIndex) {
            const recElement = document.getElementById(`rec-${recIndex}`);
            if (recElement) {
                // Mark as dismissed with visual feedback
                recElement.style.borderLeft = '4px solid #6B7280';
                recElement.style.backgroundColor = '#F3F4F6';
                recElement.style.opacity = '0.5';
                recElement.style.pointerEvents = 'none';
                recElement.classList.remove('expanded');
                recElement.classList.add('collapsed');

                // Add a data attribute to track this as dismissed
                recElement.setAttribute('data-status', 'dismissed');

                // Clear highlighting since this recommendation is dismissed
                removeAllHighlighting();

                // Update the header to show it's dismissed
                const typeElement = recElement.querySelector('.recommendation-type');
                if (typeElement) {
                    typeElement.innerHTML = '‚ùå ' + typeElement.innerHTML.replace(/^[^a-zA-Z]*/, '');
                }

                // Disable click handler for dismissed recommendations
                recElement.onclick = null;
                recElement.style.cursor = 'default';

                console.log(`‚ùå Marked recommendation ${recIndex} as dismissed`);

                showNotification('Recommendation dismissed', 'info');

                // Update score display (dismissal might reduce score slightly)
                updateScoreDisplay();

                // After dismissing, trigger re-analysis to get fresh recommendations
                setTimeout(() => {
                    console.log('üîÑ Re-analyzing after dismissal to get fresh recommendations...');
                    reAnalyzeAndUpdateRecommendations();
                }, 500);
            }
        }

        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                z-index: 1000;
                opacity: 0;
                transition: opacity 0.3s ease;
                max-width: 300px;
            `;

            // Set background color based on type
            const colors = {
                'success': '#059669',
                'warning': '#D97706',
                'error': '#DC2626',
                'info': '#4F46E5'
            };
            notification.style.backgroundColor = colors[type] || colors.info;
            notification.textContent = message;

            document.body.appendChild(notification);

            // Fade in
            setTimeout(() => notification.style.opacity = '1', 100);

            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Rerun analysis function
        function rerunAnalysis() {
            // Reset state
            currentRecommendations = [];
            currentRecommendationIndex = 0;

            // Hide progress indicator
            const progressIndicator = document.getElementById('progress-indicator');
            if (progressIndicator) {
                progressIndicator.style.display = 'none';
            }

            // Reset recommendations list
            const recommendationsElement = document.getElementById('recommendations-list');
            if (recommendationsElement) {
                recommendationsElement.innerHTML = '<div class="loading-indicator">Enhanced recommendations with actionable options will appear here</div>';
            }

            // Reset summary
            const summaryElement = document.getElementById('analysis-summary');
            if (summaryElement) {
                summaryElement.textContent = 'Click "Analyze Tone" to see directive recommendations';
            }

            // Reset issue count
            const issueCountElement = document.getElementById('issue-count');
            if (issueCountElement) {
                issueCountElement.textContent = '0 issues found';
            }

            showNotification('Ready for new analysis', 'info');
        }

        // Document type detection system
        function detectDocumentType(text) {
            const upperText = text.toUpperCase();
            const firstLines = text.split('\n').slice(0, 10).join('\n').toUpperCase();

            // Press Release Detection
            if (firstLines.includes('PRESS RELEASE') ||
                (firstLines.includes('FOR IMMEDIATE RELEASE') ||
                 firstLines.includes('CONTACT:') ||
                 (firstLines.match(/[A-Z]{2,},\s*[A-Z][a-z]+\.?\s*‚Äî/) && // Location pattern like "HENRICO, Va. ‚Äî"
                  firstLines.match(/\b(ANNOUNCE|DECLARED|STATEMENT|RELEASE)\b/)))) {

                // Detect press release subtype
                if (upperText.includes('GOVERNOR') || upperText.includes('GUBERNATORIAL')) {
                    return { type: 'press_release', subtype: 'campaign_announcement' };
                } else if (upperText.includes('ENDORSE')) {
                    return { type: 'press_release', subtype: 'endorsement' };
                } else if (upperText.includes('STATEMENT') || upperText.includes('RESPONDS')) {
                    return { type: 'press_release', subtype: 'statement' };
                }
                return { type: 'press_release', subtype: 'general' };
            }

            // Speech Detection
            if (upperText.includes('REMARKS') || upperText.includes('SPEECH') ||
                text.match(/Thank you[,.]?\s+(everyone|all)/i)) {
                return { type: 'speech', subtype: 'general' };
            }

            // Email Detection
            if (upperText.includes('SUBJECT:') || upperText.includes('FROM:') ||
                text.match(/Dear\s+[A-Z]/)) {
                return { type: 'email', subtype: 'general' };
            }

            // Letter Detection
            if (text.match(/^Dear\s+[A-Z]/m) || text.match(/Sincerely,|Best regards,|Yours truly,/i)) {
                return { type: 'letter', subtype: 'formal' };
            }

            // Social Media Detection
            if (text.length < 280 && (text.includes('@') || text.includes('#'))) {
                return { type: 'social_media', subtype: 'twitter' };
            }

            // Default to general content
            return { type: 'general', subtype: 'article' };
        }

        // Document-specific rules engine
        function getDocumentRules(documentType) {
            const rules = [];

            if (documentType.type === 'press_release') {
                rules.push(
                    {
                        type: 'formatting',
                        check: (text) => !text.match(/^[A-Z\s]+\n\n[A-Z][a-z]+\s+\d+,\s*\d{4}\n\n[A-Z\s]+\n\n[A-Z]{2,},/),
                        issue: 'Press Release Header Formatting',
                        suggestion: 'Press releases should have proper header formatting with newlines between date, headline, and location',
                        fix: (text) => {
                            // Remove "PRESS RELEASES" line and fix formatting
                            let fixed = text.replace(/^PRESS RELEASES?\s*\n/, '');
                            // Add proper spacing between elements
                            fixed = fixed.replace(/^([A-Z][a-z]+\s+\d+,\s*\d{4})\s*\n([A-Z\s]+)\s*\n([A-Z]{2,},)/m, '$1\n\n$2\n\n$3');
                            return fixed;
                        }
                    },
                    {
                        type: 'style',
                        check: (text) => text.toLowerCase().includes('announce'),
                        issue: 'Weak Action Verb',
                        suggestion: 'Use stronger action verbs like "declared" instead of "announced" in press releases',
                        examples: ['announced ‚Üí declared', 'announces ‚Üí declares']
                    },
                    {
                        type: 'structure',
                        check: (text) => !text.includes('‚Äî'),
                        issue: 'Missing Attribution Dash',
                        suggestion: 'Press releases should use em dash (‚Äî) before location for proper attribution format'
                    }
                );

                if (documentType.subtype === 'campaign_announcement') {
                    rules.push({
                        type: 'content',
                        check: (text) => !text.toLowerCase().includes('endorsement'),
                        issue: 'Missing Key Campaign Elements',
                        suggestion: 'Campaign announcements should mention key support or endorsements'
                    });
                }
            }

            return rules;
        }

        // Enhance recommendations if server only returns a few
        function enhanceRecommendations(recommendations, text) {
            // Ensure recommendations is an array
            const recArray = Array.isArray(recommendations) ? recommendations : [];
            const enhanced = [...recArray];

            // Document type detection system
            const documentType = detectDocumentType(text);
            console.log(`üìÑ Document type detected: ${documentType.type} (${documentType.subtype})`);

            // Apply document-specific rules
            const documentRules = getDocumentRules(documentType);
            console.log(`üìã Applying ${documentRules.length} document-specific rules`);

            // Apply document-specific rules to create recommendations
            documentRules.forEach(rule => {
                if (rule.check && rule.check(text)) {
                    if (rule.type === 'formatting' && rule.fix) {
                        // Add formatting fix recommendation
                        enhanced.push({
                            type: 'formatting',
                            issue: rule.issue,
                            suggestion: rule.suggestion,
                            phrase: 'PRESS RELEASES', // Target the header section
                            priority: 'high',
                            fix: rule.fix,
                            documentSpecific: true
                        });
                    } else if (rule.examples) {
                        // Add style recommendations
                        rule.examples.forEach(example => {
                            const [from, to] = example.split(' ‚Üí ');
                            if (text.toLowerCase().includes(from.toLowerCase())) {
                                enhanced.push({
                                    type: rule.type,
                                    issue: rule.issue,
                                    suggestion: rule.suggestion,
                                    phrase: from,
                                    priority: 'medium',
                                    documentSpecific: true
                                });
                            }
                        });
                    } else {
                        // Add general rule-based recommendation
                        enhanced.push({
                            type: rule.type,
                            issue: rule.issue,
                            suggestion: rule.suggestion,
                            priority: 'medium',
                            documentSpecific: true
                        });
                    }
                }
            });

            // Function to find full sentences containing a complete word or phrase
            function findFullSentenceContaining(phrase, text) {
                const sentences = text.split(/[.!?]+/);
                for (let sentence of sentences) {
                    // Use word boundaries to match complete words only
                    const wordBoundaryRegex = new RegExp(`\\b${phrase.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                    if (wordBoundaryRegex.test(sentence)) {
                        return sentence.trim() + '.';
                    }
                }
                return null; // Don't return fallback if exact word not found
            }

            // Helper function to find exact sentence in original text
            function findExactSentence(originalText, sentenceFragment) {
                console.log('üîç Finding exact sentence for fragment:', sentenceFragment.substring(0, 50) + '...');

                // Clean up the fragment for matching
                const cleanFragment = sentenceFragment.trim();

                // Try multiple matching strategies

                // Strategy 1: Look for the fragment directly in the original text
                if (originalText.includes(cleanFragment)) {
                    console.log('‚úÖ Found exact fragment match');
                    return cleanFragment;
                }

                // Strategy 2: Try to find by looking for the first 20 characters
                const firstPart = cleanFragment.substring(0, 20);
                const sentenceStart = originalText.indexOf(firstPart);
                if (sentenceStart !== -1) {
                    // Find the end of this sentence
                    const textFromStart = originalText.substring(sentenceStart);
                    const sentenceEnd = textFromStart.search(/[.!?]/);
                    if (sentenceEnd !== -1) {
                        const fullSentence = textFromStart.substring(0, sentenceEnd + 1);
                        console.log('‚úÖ Found sentence by first part match:', fullSentence.substring(0, 50) + '...');
                        return fullSentence;
                    }
                }

                // Strategy 3: Split and reconstruct
                const sentences = originalText.split(/([.!?]+)/);
                for (let i = 0; i < sentences.length; i += 2) {
                    if (sentences[i]) {
                        let currentSentence = sentences[i].trim();
                        if (sentences[i + 1]) {
                            currentSentence += sentences[i + 1];
                        }

                        // Check if this sentence contains our fragment (first 30 chars)
                        if (currentSentence.includes(cleanFragment.substring(0, 30))) {
                            console.log('‚úÖ Found sentence by split/reconstruct:', currentSentence.substring(0, 50) + '...');
                            return currentSentence;
                        }
                    }
                }

                console.log('‚ùå Could not find exact sentence, using fragment');
                // Fallback to the fragment if not found
                return cleanFragment;
            }

            // Always analyze for sentence readability issues
            if (!text || typeof text !== 'string') {
                console.log('‚ùå Invalid text provided for sentence analysis:', text);
                return enhanced;
            }
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 10);

            sentences.forEach(sentence => {
                const trimmed = sentence.trim();
                if (trimmed.length > 100) { // Long sentences
                    const wordCount = trimmed.split(' ').length;

                    // Check for run-on sentences with multiple clauses
                    if (wordCount > 25 && (trimmed.includes(', and ') || trimmed.includes('. Today,') || trimmed.includes('has been to'))) {
                        const exactSentence = findExactSentence(text, trimmed);

                        enhanced.push({
                            type: 'clarity',
                            issue: 'Long, complex sentence needs breaking up',
                            examples: [exactSentence], // Use exact text from original
                            suggestion: 'Break this long sentence into shorter, more impactful statements',
                            priority: 'high'
                        });
                    }

                    // Check for awkward transitions
                    if (trimmed.includes('has been to') && trimmed.includes('Today, I am')) {
                        const exactSentence = findExactSentence(text, trimmed);
                        enhanced.push({
                            type: 'clarity',
                            issue: 'Awkward sentence structure and transitions',
                            examples: [exactSentence],
                            suggestion: 'Restructure to improve flow and readability',
                            priority: 'high'
                        });
                    }
                }
            });

            // Add comprehensive recommendations for political communication
            if (enhanced.length < 8) {
                console.log('üìà Enhancing recommendations - adding comprehensive improvements');

                const comprehensiveImprovements = [
                    // Engagement improvements
                    {
                        type: 'engagement',
                        issue: 'Add more direct voter appeal',
                        phrase: 'working hard',
                        suggestion: 'Strengthen connection with voters by using more direct, personal language',
                        priority: 'medium'
                    },
                    {
                        type: 'engagement',
                        issue: 'Make language more conversational',
                        phrase: 'represent',
                        suggestion: 'Use simpler, more accessible language that resonates with all voters',
                        priority: 'low'
                    },
                    {
                        type: 'engagement',
                        issue: 'Connect with voter concerns',
                        phrase: 'today',
                        suggestion: 'Frame statements in terms of immediate voter benefits and concerns',
                        priority: 'medium'
                    },
                    // Confidence improvements
                    {
                        type: 'confidence',
                        issue: 'Project stronger leadership',
                        phrase: 'look forward',
                        suggestion: 'Use more decisive language that projects confidence and leadership',
                        priority: 'medium'
                    },
                    {
                        type: 'confidence',
                        issue: 'Strengthen declarative language',
                        phrase: 'announce',
                        suggestion: 'Consider using stronger, more decisive language for key declarations',
                        priority: 'low'
                    },
                    {
                        type: 'confidence',
                        issue: 'Eliminate weak language',
                        phrase: 'trying',
                        suggestion: 'Replace tentative language with strong, committed statements',
                        priority: 'high'
                    },
                    // Action-oriented improvements
                    {
                        type: 'tone_improvement',
                        issue: 'Add specific action plans',
                        phrase: 'helping',
                        suggestion: 'Replace vague helping language with specific action commitments',
                        priority: 'medium'
                    },
                    {
                        type: 'tone_improvement',
                        issue: 'Emphasize concrete results',
                        phrase: 'support',
                        suggestion: 'Focus on tangible outcomes and measurable results for voters',
                        priority: 'medium'
                    },
                    // Professional polish
                    {
                        type: 'clarity',
                        issue: 'Improve sentence flow',
                        phrase: 'important',
                        suggestion: 'Restructure to create stronger, more impactful statements',
                        priority: 'low'
                    },
                    {
                        type: 'clarity',
                        issue: 'Eliminate redundancy',
                        phrase: 'continue',
                        suggestion: 'Remove redundant phrases and tighten language for maximum impact',
                        priority: 'low'
                    }
                ];

                comprehensiveImprovements.forEach(improvement => {
                    if (enhanced.length < 12) { // Increased limit for more suggestions
                        const foundSentence = findFullSentenceContaining(improvement.phrase, text);
                        if (foundSentence) {
                            enhanced.push({
                                type: improvement.type,
                                issue: improvement.issue,
                                examples: [foundSentence],
                                suggestion: improvement.suggestion,
                                priority: improvement.priority
                            });
                        }
                    }
                });
            }

            // Add general improvements for any remaining gaps
            if (enhanced.length < 8) {
                console.log('üìä Adding general political communication improvements');
                const generalSentences = text.split(/[.!?]+/).filter(s => s.trim().length > 20);

                generalSentences.slice(0, 3).forEach((sentence, index) => {
                    if (enhanced.length < 12) {
                        const exactSentence = findExactSentence(text, sentence.trim());
                        enhanced.push({
                            type: 'tone_improvement',
                            issue: `Enhance political messaging impact (${index + 1})`,
                            examples: [exactSentence],
                            suggestion: 'Consider strengthening this statement with more decisive, voter-focused language',
                            priority: 'low'
                        });
                    }
                });
            }

            return enhanced;
        }

        // Update remaining recommendations to match current text
        function updateRemainingRecommendations(currentText) {
            console.log('üìù Updating remaining recommendations to match current text');

            // For each recommendation that hasn't been applied yet
            currentRecommendations.forEach((rec, index) => {
                const recElement = document.getElementById(`rec-${index}`);
                if (recElement && recElement.style.opacity !== '0.7' && recElement.style.opacity !== '0.5') {
                    // This recommendation hasn't been applied yet
                    // Try to find if the original text still exists in the updated content
                    if (rec.examples && rec.examples.length > 0) {
                        const originalExample = rec.examples[0];

                        // Check if the exact text still exists
                        if (!currentText.includes(originalExample)) {
                            // The text may have been modified by a previous recommendation
                            // Try to find a similar sentence
                            const sentences = currentText.split(/[.!?]+/);

                            // Look for sentences containing key words from the original
                            const keyWords = originalExample.split(' ').filter(w => w.length > 4);
                            for (let sentence of sentences) {
                                if (keyWords.some(word => sentence.includes(word))) {
                                    // Found a sentence with similar content, update the example
                                    rec.examples[0] = sentence.trim() + '.';
                                    console.log(`üìù Updated recommendation ${index} example to: "${rec.examples[0]}"`);
                                    break;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Make functions globally available
        window.runToneAnalysis = runToneAnalysis;
        window.updateRemainingRecommendations = updateRemainingRecommendations;
        window.loadSampleContent = loadSampleContent;
        window.undoLastChange = undoLastChange;
        window.enableUndo = enableUndo;
        window.selectAlternative = selectAlternative;
        window.applyRecommendation = applyRecommendation;
        window.highlightInText = highlightInText;
        window.dismissRecommendation = dismissRecommendation;
        window.rerunAnalysis = rerunAnalysis;
        window.expandRecommendation = expandRecommendation;
        window.selectAndApplyAlternative = selectAndApplyAlternative;

        // Add keyboard shortcuts for faster workflow
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                // Only handle shortcuts when not typing in the editor
                if (e.target.id === 'text-editor') return;

                switch(e.key) {
                    case 'Enter':
                    case ' ':
                        // Apply current recommendation with Enter or Space
                        e.preventDefault();
                        const activeRec = document.querySelector('.recommendation[style*="border-left: 4px solid rgb(245, 158, 11)"]');
                        if (activeRec) {
                            const recId = activeRec.id.replace('rec-', '');
                            applyRecommendation(parseInt(recId));
                        }
                        break;
                    case 'ArrowDown':
                    case 'j':
                        // Move to next recommendation
                        e.preventDefault();
                        moveToNextAvailableRecommendation(1);
                        break;
                    case 'ArrowUp':
                    case 'k':
                        // Move to previous recommendation
                        e.preventDefault();
                        moveToNextAvailableRecommendation(-1);
                        break;
                    case 'Escape':
                    case 'd':
                        // Dismiss current recommendation
                        e.preventDefault();
                        const currentRec = document.querySelector('.recommendation[style*="border-left: 4px solid rgb(245, 158, 11)"]');
                        if (currentRec) {
                            const recId = currentRec.id.replace('rec-', '');
                            dismissRecommendation(parseInt(recId));
                        }
                        break;
                }
            });
        }

        function moveToNextAvailableRecommendation(direction) {
            let nextIndex = -1;
            const availableRecs = [];

            // Find all available (non-applied, non-dismissed) recommendations
            for (let i = 0; i < currentRecommendations.length; i++) {
                const recElement = document.getElementById(`rec-${i}`);
                if (recElement && recElement.style.opacity !== '0.7' && recElement.style.opacity !== '0.5') {
                    availableRecs.push(i);
                }
            }

            if (availableRecs.length > 0) {
                const currentIndex = availableRecs.indexOf(currentRecommendationIndex);
                const newIndex = currentIndex + direction;

                if (newIndex >= 0 && newIndex < availableRecs.length) {
                    nextIndex = availableRecs[newIndex];
                } else if (direction > 0) {
                    nextIndex = availableRecs[0]; // Wrap to first
                } else {
                    nextIndex = availableRecs[availableRecs.length - 1]; // Wrap to last
                }

                if (nextIndex !== -1) {
                    highlightInText(nextIndex);
                    currentRecommendationIndex = nextIndex;
                }
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            console.log('‚úÖ Enhanced Recommendations Editor initialized');

            // Initialize empty state
            currentText = '';
            undoStack = [];
            saveState(); // Save initial empty state

            setupKeyboardShortcuts(); // Setup keyboard navigation

            // Set up overlay scrolling sync and text change detection
            const editor = document.getElementById('text-editor');
            let reAnalysisTimeout;

            if (editor) {
                editor.addEventListener('scroll', syncOverlayScroll);
                editor.addEventListener('input', function() {
                    // Clear highlights when text is modified
                    removeAllHighlighting();
                    enableUndo();

                    // Re-analyze after manual text changes (debounced)
                    if (currentRecommendations.length > 0) {
                        console.log('üìù Text modified manually, scheduling re-analysis...');

                        // Clear existing timeout
                        if (reAnalysisTimeout) {
                            clearTimeout(reAnalysisTimeout);
                        }

                        // Set new timeout for re-analysis (3 seconds after last change)
                        reAnalysisTimeout = setTimeout(() => {
                            console.log('üîÑ Triggering re-analysis due to manual text changes');
                            reAnalyzeAndUpdateRecommendations();
                        }, 3000);
                    }
                });
            }

            // Test server connection
            fetch('/api/health')
                .then(response => response.json())
                .then(data => {
                    console.log('‚úÖ Server connection successful:', data);
                })
                .catch(error => {
                    console.log('‚ùå Server connection failed:', error);
                    const statusSpan = document.querySelector('.status-indicator span');
                    const statusDot = document.querySelector('.status-dot');
                    if (statusSpan) statusSpan.textContent = 'Server connection failed';
                    if (statusDot) statusDot.style.background = '#e53e3e';
                });
        });

        // Log that functions are available
        console.log('üîß Functions registered:', {
            runToneAnalysis: typeof runToneAnalysis,
            loadSampleContent: typeof loadSampleContent,
            undoLastChange: typeof undoLastChange
        });
    </script>
</body>
</html>